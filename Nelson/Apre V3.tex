\documentclass[slidestop,compress,mathserif,9pt]{beamer}
\usepackage{graphics,graphicx}
\DeclareGraphicsExtensions{.pdf}
\DeclareGraphicsExtensions{.png}
\DeclareMathOperator*{\Limsup}{Limsup}
%------------------------
\usepackage[]{hyperref}
\setlength{\parindent}{1em}
\setlength{\parskip}{0.5em}
\usepackage{amsmath}
\usepackage[makeroom]{cancel}
\usepackage{amsmath,amssymb,mathrsfs,amsthm}
\usepackage{array}
\usepackage{cite}
\usepackage{epstopdf}
\usepackage{hyperref}
\usepackage{stmaryrd}
\usepackage{graphicx,color}
\usepackage{url}
\usepackage{lmodern}
%\textwidth 15cm
%\textheight 22cm
%\hoffset -1.5cm
%\voffset -1cm
\def\N{\mathbb{N}}
\def\R{\mathbb{R}}
\def\C{\mathbb{C}}
\def\H{{\mathbb{H}}}
\def\HH{\ensuremath{\mathbb{H}}}
\def\HCO{{\mathbb{H}}_{\rm{coq}}}
\def\ll{\llbracket}
\def\rr{\rrbracket}

%--------------------------------------------------------------------

\usepackage[latin1]{inputenc}
\usepackage[portuges]{babel}
\newtheorem{teor}{Teorema}[section]
\newtheorem{coro}{Corol\'ario}[section]
\theoremstyle{definition}
\newtheorem{defi}{Defini\c c\~ao}[section]
\theoremstyle{definition}
\newtheorem{exemplo}{Exemplo}[section]
\theoremstyle{theorem}
\newtheorem{propo}{Proposi\c c\~ao}[section]
\newtheorem{nota}{Nota}[section]



\mode<presentation>
{
	\usetheme{Antibes}
	%\usetheme{Warsaw}
}

\title
{...Machine Learning...}

\author[Artur, Ezequiel, Nelson] 
{Artur \and Ezequiel \and Nelson}

\institute
{Universidade do Minho}

\date{26 de Abril} 

\begin{document}
	
	\begin{frame}
	\titlepage
\end{frame}

\begin{frame}{Indice}
\tableofcontents
\end{frame}

% - Exactly two or three sections (other than the summary).
% - At *most* three subsections per section.
% - Talk about 30s to 2min per frame. So there should be between about
%   15 and 30 frames, all told.

\section{Nelson}

\begin{frame}{titulo}
\end{frame}





\section{Categorias}

\begin{frame}{Uma curta introdução}
\vspace{10mm}
\begin{itemize}
\item<1-> Queremos calcular $\mathcal{D}^{+}$.
\vspace{1mm}
\item<2-> Problema: $\mathcal{D}$ não é computável.
\vspace{1mm}
\item<3-> Solução: observar corolários apresentados e implementar recorrendo a categorias.
\end{itemize}

\end{frame}



\begin{frame}{Uma curta introdução}
\vspace{10mm}
\begin{block}{Corolário 1.1}
NOTA: adicionar definição do corolário 1.1 aqui
\end{block}

\begin{block}{Corolário 2.1}
NOTA: adicionar definição do corolário 2.1 aqui
\end{block}

\begin{block}{Corolário 3.1}
NOTA: adicionar definição do corolário 3.1 aqui
\end{block}

\end{frame}


\begin{frame}
\frametitle{Definição de Derivada}
\vspace{5mm}

\begin{defi}
	Seja $f:\R \to \R$ uma função. A derivada de $f$ no ponto $x \in \R$ é definido da seguinte forma:
	\begin{align*}
	\textit{$f $$'$ $(x)$} = \ \lim_{\varepsilon \to 0} \frac{\textit{$f$($x$ $+$ $\varepsilon$) - $f(x)$}}{\varepsilon}
	\end{align*}
\end{defi}
\vspace{5mm}
\pause
A definição acima também funcionará para funções de tipos $\C \hspace{0.5mm}\to \C$ e $\R\hspace{0.6mm} \to \R^{n}$.

\end{frame}
\begin{frame}
\frametitle{Definição de Derivada}
\vspace{10mm}
Para funções $F$ de tipos $\R^{m}\hspace{-0.3mm} \to \R$ e $\R^{m}\hspace{-0.3mm}\to \R^{n}$ (com $n>1$), precisamos de uma definição diferente.
\pause
\vspace{1mm}
	\begin{itemize}
	\item Em funções $\R^{m}\hspace{-0.3mm} \to \R$ é necessário introduzir a noção de derivadas parciais, $\frac{\partial F}{\partial x_{j}}\hspace{0.3mm}$, com $j \in$ \{$1,...,m$\}.
	
	\pause
	\vspace{3mm}
	\item Em funções $\R^{m}\hspace{-0.3mm}\to \R^{n}$ (com $n>1$), para além de derivadas parciais, é necessário utilizar matrizes Jacobianas $\mathbf{J}_{i,j} =\frac{\partial F_{i}}{\partial x_{j}}$, onde $i \in$ \{$1,...,n$\} e $F_{i}$ é uma função $\R^{m}\hspace{-0.3mm}\to \R$.
\end{itemize} 
\end{frame}

\begin{frame}
\frametitle{Generalização e Regra da Cadeia}
\vspace{15mm}
Sejam $\mathbf{A}$ e $\mathbf{B}$ duas matrizes Jacobianas. 

A regra da cadeia em $\R^{m}\hspace{-0.3mm}\to \R^{n}$ é:
\begin{align*}
(\mathbf{A} \cdotp \mathbf{B})_{i,j}= \sum_{k=1}^{m} \mathbf{A}_{i,k} \cdotp \mathbf{B}_{k,j}
\end{align*}
\end{frame}

\begin{frame}
\frametitle{Generalização e Regra da Cadeia}
\vspace{15mm}
Assumindo que a noção de derivada que queremos corresponde a uma transformação linear, onde é aceita a regra da cadeia vista anteriormente, vamos definir uma nova generalização:
\pause

\begin{align*}
\hspace{-2mm} \lim_{\varepsilon \to 0} \frac{\textit{$f$($x$ $+$ $\varepsilon$) - $f(x)$}}{\varepsilon} - \textit{$f $$'$ $(x)$} = 0 \hspace{0.5mm} 
\Leftrightarrow \hspace{0.5mm} \lim_{\varepsilon \to 0} \frac{\textit{$f$($x$ $+$ $\varepsilon$) - ($f(x)$} + \varepsilon \cdotp \textit{$f $$'$ $(x)$}) )}{\varepsilon} = 0 \\
& \hspace{-5.9cm}  \Leftrightarrow  \lim_{\varepsilon \to 0} \frac{ \| \textit{$f$($x$ $+$ $\varepsilon$) - ($f(x)$} + \varepsilon \cdotp \textit{$f $$'$ $(x)$}) ) \|}{\| \varepsilon \|} = 0
\end{align*}

\end{frame}
\begin{frame}
\begin{center}
	\frametitle{Derivada como transformação linear} 
\end{center}
\begin{defi}
	Seja $f::a \to b$ uma função, onde $a$ e $b$ são espaços vetoriais com base no mesmo corpo. A primeira definição de derivada é da seguinte forma:
	\begin{align*} 
	\mathcal{D} :: (a \to b) \to (a \to (a \multimap b))
	\end{align*}
	Se diferenciamos duas vezes temos:
	\begin{align*} 
	 \mathcal{D}^{2} = \mathcal{D} \circ \mathcal{D} :: (a \to b) \to (a \to (a \multimap a \multimap b ))
	\end{align*}
\end{defi}
\end{frame}

\begin{frame}
\frametitle{Regras de diferenciação - Composição}
\vspace{15mm}
\begin{teor}
	
	Sejam $f:: a \to b$ e  $g:: b \to c$ duas funções. Então a derivada da composta de $f$ e $g$ é
	\begin{align*}
	\mathcal{D} \ (g \circ f ) \ a= \mathcal{D} \hspace{0.9mm} g \hspace{1.0mm}  (f \hspace{0.5mm} a)   \hspace{0.6mm} \circ \hspace{0.6mm} \mathcal{D} \hspace{0.6mm} f \ a
	\end{align*}
\end{teor}
\end{frame}
\begin{frame}
\frametitle{Regras de diferenciação - Composição}
\vspace{10mm}
Como infelizmente o teorema anterior não é uma regra eficiente para a composição, vamos introduzir uma segunda definição de derivada:
\begin{align*}
\mathcal{D}_{0}^{+} :: (a \to b) \to ((a \to b) \times (a \to (a \multimap b))) \\
& \hspace{-6.18cm} \mathcal{D}_{0}^{+} \hspace{0.5mm} f =(f,\hspace{0.2mm} \mathcal{D} f)
\end{align*}
\pause

Com isto a regra da cadeia ficará da seguinte forma:

$\mathcal{D}_{0}^{+} \hspace{0.5mm} (g \circ f) $ =

$= (g \circ f,\hspace{0.2mm} \mathcal{D} \hspace{0.5mm} (g \circ f) \hspace{0.5mm})$ \hspace{3.41cm} (definição de $\mathcal{D}_{0}^{+}$)

$= (\lambda a \to g (f \hspace{0.5mm} a),\hspace{0.2mm} \lambda a \to \mathcal{D} \hspace{0.9mm} g \hspace{1.0mm}  (f \hspace{0.5mm} a)   \hspace{0.5mm} \circ \hspace{0.5mm} \mathcal{D} \hspace{0.5mm} f \hspace{0.5mm} a )$ \hspace{4mm} (Teorema e definição de $g \circ f$)
\end{frame}
\begin{frame}
\frametitle{Regras de diferenciação - Composição} 
\vspace{9mm}
Tendo em mente otimizações, vamos introduzir a última definição de derivada:
\begin{align*}
\mathcal{D}^{+} :: (a \to b) \to (a \to (b \times (a \multimap b)  \\
& \hspace{-5cm}\mathcal{D}^{+} \hspace{0.5mm} f \hspace{0.9mm} a = (f \hspace{0.5mm} a,\hspace{0.2mm} \mathcal{D} \hspace{0.5mm} f \hspace{0.5mm} a )
\end{align*}
\pause

Como $\times$ tem mais prioridade do que $\to$ e $\multimap$, podemos reescrever $\mathcal{D}^{+} $ da seguinte forma:
\begin{align*}
\mathcal{D}^{+} :: (a \to b) \to (a \to b \times (a \multimap b))  \\
& \hspace{-5cm}\mathcal{D}^{+} \hspace{0.5mm} f \hspace{0.9mm} a = (f \hspace{0.5mm} a,\hspace{0.2mm} \mathcal{D} \hspace{0.5mm} f \hspace{0.5mm} a )
\end{align*}
\end{frame}
\begin{frame}
\frametitle{Regras de diferenciação - Composição} 
\vspace{15mm}
\begin{coro}
	$\mathcal{D}^{+}$ é eficientemente composicional em relação a $(\circ)$, ou seja, em linguagem Haskell:
	\begin{align*}
	 \mathcal{D}^{+} \hspace{0.5mm} (g \circ f) \hspace{0.9mm} a = \textbf{let} \hspace{0.5mm} \{(b,\hspace{0.2mm} f') = \mathcal{D}^{+} \hspace{0.5mm} f \hspace{0.9mm} a; \hspace{0.5mm} (c,\hspace{0.2mm} g')=\mathcal{D}^{+} \hspace{0.5mm} g \hspace{0.9mm} b \} \hspace{1mm} \textbf{in} \hspace{1mm} (c,\hspace{0.2mm} g' \circ f') 
	\end{align*}
\end{coro}
\end{frame}
\begin{frame}
\frametitle{Regras de diferenciação - Split} 
\vspace{10mm}
Outra forma importante de combinar funçõe é a operação cross, que combina duas funções de forma paralela:
\begin{align*}
(\boldsymbol{\times}) :: (a \to c) \to (b \to d) \to (a \times b \to c \times d) \\
& \hspace{-6.23cm}f \boldsymbol{\times} g = \lambda(a,\hspace{0.5mm} b) \to (f \hspace{0.5mm} a,\hspace{0.2mm} g \hspace{0.5mm} b) 
\end{align*}
\pause
\begin{teor}	
	Seja $f :: a \to c$ e $g :: b \to d$ duas funções. Então a regra do cross é da seguinte forma:
	\begin{align*}
	\mathcal{D} \hspace{0.5mm} (f \boldsymbol{\times} g) \hspace{0.5mm} (a,\hspace{0.2mm} b) = \mathcal{D} \hspace{0.5mm} f \hspace{0.9mm} a \boldsymbol{\times} \mathcal{D} \hspace{0.5mm} g \hspace{0.9mm} b
	\end{align*}
\end{teor}
\end{frame}
\begin{frame}
\frametitle{Regras de diferenciação - Split} 
\vspace{15mm}
\begin{coro}
	A função $\mathcal{D}^{+}$ é composicional em relação a $(\boldsymbol{\times})$
	\begin{align*}
	 \mathcal{D}^{+} \hspace{0.5mm} (f \boldsymbol{\times} g) \hspace{0.9mm} (a,\hspace{0.2mm} b) = \textbf{let} \hspace{0.5mm} \{(c,\hspace{0.2mm} f') = \mathcal{D}^{+} \hspace{0.3mm} f \hspace{0.7mm} a; \hspace{0.5mm} (d,\hspace{0.2mm} g')=\mathcal{D}^{+} \hspace{0.3mm} g \hspace{0.7mm} b \} \hspace{0.8mm} \textbf{in} \hspace{0.8mm}  ((c,\hspace{0.2mm} d), \hspace{0.2mm} f' \boldsymbol{\times} g') 
	\end{align*}
\end{coro}
\end{frame}
\begin{frame}
\frametitle{Derivada e funções lineares} 
\vspace{5mm}
\begin{defi}
	Uma função $f$ diz-se linear quando preserva a adição e a multiplicação escalar.
	\vspace{2mm}
	
	\hspace{5mm} $f(a + a')= f \hspace{0.5mm} a + f \hspace{0.5mm} a'$
	
	\vspace{1mm}
	\hspace{5mm} $f(s \cdot a)= s \cdot f \hspace{0.5mm} a$

\end{defi}
\pause
\vspace{4mm}
\begin{teor}
	Para todas as funções lineares $f$, $\mathcal{D} \hspace{0.5mm} f \hspace{0.9mm} a = f $.
\end{teor}
\pause
\vspace{2mm}
\begin{coro}
	Para todas as funções lineares $f$, $\mathcal{D}^{+} \hspace{0.5mm} f = \lambda a \to (fa,\hspace{0.5mm} f)$.
\end{coro}
\end{frame}
\begin{frame}{Categorias clássicas}

Uma categoria é um conjunto de objetos(conjuntos e tipos) e de morfismos(operações entre objetos).
Uma categoria tem definidas 2 operações básicas, identidade e composição de morfismos, e 2 leis:

\begin{itemize}
	\item (C.1) \textbf{-----} $id \circ f = id \circ f = f$ 
	\item (C.2) \textbf{-----} $f \circ (g \circ h) = (f \circ g) \circ h$ 
\end{itemize}

\end{frame}

\begin{frame}{Categorias clássicas}

Uma categoria é um conjunto de objetos(conjuntos e tipos) e de morfismos(operações entre objetos).
Uma categoria tem definidas 2 operações básicas, identidade e composição de morfismos, e 2 leis:

\begin{itemize}
	\item (C.1) \textbf{-----} $id \circ f = id \circ f = f$ 
	\item (C.2) \textbf{-----} $f \circ (g \circ h) = (f \circ g) \circ h$
\end{itemize}


\begin{block}
	
	Para os efeitos deste papel, objetos são tipos de dados e morfismos são funções.
	
\end{block}

\begin{block}
	
	\begin{columns}
		
		\column{0.5\textwidth}
	\hspace{3mm}	class \textit{Category k} where
		
		\hspace{0.5cm}id :: (a'k'a)
		
		\hspace{0.45cm}($\circ$) :: (b'k'c) $\rightarrow$ (a'k'b) $\rightarrow$ (a'k'c)
		
		\column{0.5\textwidth}
		instance \textit{Category ($\rightarrow$)} where
		
		\hspace{0.2cm}id = $\lambda$a $\rightarrow$ a 
		
		\hspace{0.2cm}$g \circ f = \lambda$a $\rightarrow$ g (f a)  
		
	\end{columns}
	
\end{block}

\end{frame}




\begin{frame}{Functores clássicos}
\vspace{2.5mm}

Um functor \textit{F} entre categorias $\mathcal{U}$ e $\mathcal{V}$ é tal que:
\begin{itemize}
\item para qualquer objeto t $\in \mathcal{U}$ temos que \textit{F} t $\in \mathcal{V}$
\item para qualquer morfismo m :: a $\rightarrow$ b $\in \mathcal{U}$ temos que \textit{F} m :: \textit{F} a $\rightarrow$ \textit{F} b $\in \mathcal{V}$
\item \textit{F} id ($\in \mathcal{U}$) = id ($\in \mathcal{V}$)
\item \textit{F} ($f \circ g$) = \textit{F} f $\circ$ \textit{F} g
\end{itemize}


\begin{block}{Nota}
Devido à definição de categoria deste papel(objetos são tipos de dados) os functores mapeiam tipos neles próprios.
\end{block}

\end{frame}

\begin{frame}{Objetivo}
\vspace{2.5mm}
Começamos por definir um novo tipo de dados:

newtype $\mathcal{D}$ a b = $\mathcal{D}$ ($a \rightarrow b \times (a \multimap b)$)

Depois adaptamos $\mathcal{D}^{+}$ para usar este tipo de dados:

\begin{block}{Definição adaptada}

$\mathcal{\hat{D}}$ :: (a $\rightarrow$ b) $\rightarrow$ $\mathcal{D}$ a b

$\mathcal{\hat{D}}$ f = $\mathcal{D}$ ($\mathcal{D}^{+}$ f)

\end{block}

O nosso objetivo é a dedução de uma instância de categoria para $\mathcal{D}$ onde $\mathcal{\hat{D}}$ seja functor.


\end{frame}



\begin{frame}{Dedução da instância}
\vspace{2.5mm}
Recordando os corolários 3.1 e 1.1 deduzimos que
\begin{itemize}
\item (DP.1) \textbf{-----} $\mathcal{D}^{+} id$ = $\lambda$a $\rightarrow$ (id a,\hspace{0.5mm}id)
\item (DP.2) \textbf{-----}

$\mathcal{D}^{+}(g \circ f)$ = $\lambda a \rightarrow let\{(b,\hspace{0.5mm} f')$ = $\mathcal{D}^{+}$ f a; $(c,g') = \mathcal{D}^{+}$ g b \} in $(c,\hspace{0.5mm} g' \circ f'$)   
\end{itemize}

$\mathcal{\hat{D}}$ ser functor é equivalente a dizer que, para todas as funções f e g de tipos apropriados:

\begin{itemize}
\item id = $\mathcal{\hat{D}}$ id = $\mathcal{D}$ $(\mathcal{D}^{+} id)$
\item $\mathcal{\hat{D}}$ g $\circ$ $\mathcal{\hat{D}}$ f = $\mathcal{\hat{D}}$  (g $\circ$ f) = $\mathcal{D}$ $ (\mathcal{D}^{+} (g \circ f))$
\end{itemize}

\end{frame}


\begin{frame}{Dedução da instância}
\vspace{2.5mm}
Com base em (DP.1) e (DP.2) podemos reescrever como sendo:
\begin{itemize}
\item id = $\mathcal{D} (\lambda$a $\rightarrow$ (id a,\hspace{0.2mm}id))
\item $\mathcal{\hat{D}}$ g $\circ$ $\mathcal{\hat{D}}$ f = $\mathcal{D}$ ( $\lambda a \rightarrow let\{(b,\hspace{0.2mm}f')$ = $\mathcal{D}^{+}$ f a; $(c,\hspace{0.2mm}g') = \mathcal{D}^{+}$ g b \} in $(c,\hspace{0.2mm}g' \circ f'$) )
\end{itemize}

Resolver a primeira equação é trivial(definir id da instância como sendo \\
$\mathcal{D} (\lambda$a $\rightarrow$ (id a,\hspace{0.2mm}id))).


A segunda equação será resolvida resolvendo uma condição mais geral:
$\mathcal{D} g \circ \mathcal{D} f$ = $\mathcal{D}$ ($\lambda a \rightarrow let\{(b,\hspace{0.2mm}f')$ = f a; $(c,\hspace{0.2mm}g')$ = g b \} in $(c,\hspace{0.2mm}g' \circ f'$)), cuja solução é igualmente trivial.


\end{frame}

\begin{frame}{Dedução da instância}
\vspace{2.5mm}

\begin{block}{Definição de $\mathcal{\hat{D}}$ para funções lineares}
linearD :: (a $\rightarrow$ b) $\rightarrow$ $\mathcal{D}$ a b

linearD f = $\mathcal{D}$ ($\lambda$a $\rightarrow$ (f a,f))
\end{block}

\begin{block}{Instância da categoria que deduzimos}

instance \textit{Category $\mathcal{D}$} where

\hspace{0.2cm}id = linearD id

\hspace{0.2cm}$\mathcal{D} g \circ \mathcal{D} f$ = $\mathcal{D}$ ($\lambda a \rightarrow let\{(b,f')$ = f a; $(c,g')$ = g b \} in $(c,g' \circ f'$))

\end{block}


\end{frame}



\begin{frame}{Prova da instância}
\vspace{2.5mm}
Antes de continuarmos devemos verificar se esta instância obedece às leis (C.1) e (C.2).

Se considerarmos apenas morfismos $\hat{f}$ :: $\mathcal{D}$ a b tal que $\hat{f}$ = $\mathcal{D}^{+}$ f para \\
f :: a $\rightarrow$ b (o que podemos garantir se transformarmos $\mathcal{D}$ a b em tipo abstrato) podemos garantir que $\mathcal{D}^{+}$ é functor.


\begin{block}{Prova de (C.1)}

\hspace{2.5mm} id $\circ \mathcal{\hat{D}}$ 

\vspace{1.5mm}
=  $\mathcal{\hat{D}}$ $id \circ \mathcal{\hat{D}}$ f -lei functor de id (especificação de $\mathcal{\hat{D}}$)

\vspace{1mm}
= $\mathcal{\hat{D}}$ (id $\circ$ f) - lei functor para ($\circ$)

\vspace{1mm}
= $\mathcal{\hat{D}}$ f - lei de categoria
\end{block}


\end{frame}

\begin{frame}{Prova da instância}
\vspace{2.5mm}
\begin{block}{Prova de (C.2)}

\hspace{2.5mm} $\mathcal{\hat{D}}$ h $\circ$ ($\mathcal{\hat{D}}$ g $\circ$ $\mathcal{\hat{D}}$ f)

\vspace{1.5mm}
= $\mathcal{\hat{D}}$ h $\circ$ $\mathcal{\hat{D}}$ (g $\circ$ f) - lei functor para ($\circ$)

\vspace{1mm}
= $\mathcal{\hat{D}}$ (h $\circ$ (g $\circ$ f)) - lei functor para ($\circ$)

\vspace{1mm}
= $\mathcal{\hat{D}}$ ((h $\circ$ g) $\circ$ f) - lei de categoria

\vspace{1mm}
= $\mathcal{\hat{D}}$ (h $\circ$ g) $\circ$ $\mathcal{\hat{D}}$  f - lei functor para ($\circ$)

\vspace{1mm}
= ($\mathcal{\hat{D}}$ h $\circ$ $\mathcal{\hat{D}}$ g) $\circ$ $\mathcal{\hat{D}}$ f - lei functor para ($\circ$)

\end{block}

\begin{alertblock}{Nota}
Estas provas não requerem nada de $\mathcal{D}$ e $\mathcal{\hat{D}}$ para além das leis do functor, logo nas próximas instâncias deduzidas de um functor não precisamos de voltar a realizar estas provas.

\end{alertblock}

\end{frame}




\begin{frame}{Categorias e functores monoidais}
\vspace{2.5mm}
A versão generalizada da composição paralela será definida através de uma categoria monoidal:

\begin{block}


\begin{columns}

\column{0.5\textwidth}
class \textit{Category k} $\Rightarrow$ \textit{Monoidal k} where

\hspace{0.2cm}($\times$)::(a'k'c)$\rightarrow$(b'k'd)$\rightarrow$((a$\times$b)'k'(c$\times$d))

\column{0.4\textwidth}
instance \textit{Monoidal ($\rightarrow$)} where


\vspace*{3.5mm}
\hspace{0.2cm}$f \times g= \lambda$(a,b)$\rightarrow$(f a,g b)  

\end{columns}

\end{block}


\begin{block}{Definição de functor monoidal}

Um functor \textit{F} monoidal entre categorias $\mathcal{U}$ e $\mathcal{V}$ é tal que:
\begin{itemize}
\item \textit{F} é functor clássico
\item \textit{F} (f $\times$ g) = \textit{F} f $\times$ \textit{F} g
\end{itemize}

\end{block}

\end{frame}



\begin{frame}{Dedução da instância}
\vspace{2.5mm}
A partir do corolário 2.1 deduzimos que:
\vspace{-0.5mm}

$\mathcal{D}^{+}$ (f $\times$ g) = $\lambda$(a,b) $\rightarrow$ let\{(c,f')= $\mathcal{D}^{+}$ f a; (d,g') = $\mathcal{D}^{+}$ g b \}\\ 
in ((c,d),f' $\times$ g')

\vspace{1mm}
Se definirmos o functor F a partir de $\mathcal{\hat{D}}$ chegamos à seguinte condição:

\vspace{-0.5mm}
$\mathcal{D}$ ($\mathcal{D}^{+}$ f) $\times$ $\mathcal{D}$ ($\mathcal{D}^{+}$ g) = $\mathcal{D}$ ($\mathcal{D}^{+}$ (f $\times$ g))

\vspace{1mm}
Substituindo e fortalecendo-a obtemos:

\vspace{-0.5mm}
$\mathcal{D}$ f $\times$ $\mathcal{D}$ g = $\mathcal{D}$ ($\lambda$(a,b) $\rightarrow$ let\{(c,f') = f a; (d,g') =  g b \} in ((c,d),f' $\times$ g'))

\vspace{-0.5mm}
e esta condição é suficiente para obtermos a nossa instância.

\end{frame}


\begin{frame}{Dedução da instância}
\vspace{2.5mm}
\begin{block}{Instância da categoria que deduzimos}

instance \textit{Monoidal $\mathcal{D}$} where

\hspace{0.2cm}$\mathcal{D}$ f $\times$ $\mathcal{D}$ g = $\mathcal{D}$($\lambda$(a,b) $\rightarrow$ let\{(c,f') = f a; (d,g') =  g b \} in ((c,d),f'$\times$g'))

\end{block}

\end{frame}



\begin{frame}{Categorias e funtores cartesianas}

\begin{block}

\begin{columns}

\column{0.5\textwidth}
class \textit{Monoidal k} $\Rightarrow$ \textit{Cartesean k} where

\hspace{0.2cm}exl :: (a$\times$b)'k'a

\hspace{0.2cm}exr :: (a$\times$b)'k'b

\hspace{0.2cm}dup :: a'k'(a$\times$a)

\column{0.4\textwidth}
instance \textit{Cartesean ($\rightarrow$)} where

\hspace{0.2cm}exl = $\lambda$(a,b) $\rightarrow$ a

\hspace{0.2cm}exr = $\lambda$(a,b) $\rightarrow$ b

\hspace{0.2cm}dup = $\lambda$a $\rightarrow$ (a,a)

\end{columns}

\end{block}


\begin{block}


Um functor \textit{F} cartesiano entre categorias $\mathcal{U}$ e $\mathcal{V}$ é tal que:
\begin{itemize}
\item \textit{F} é functor monoidal
\item \textit{F} exl = exl
\item \textit{F} exp = exp
\item \textit{F} dup = dup
\end{itemize}


\end{block}


\end{frame}




\begin{frame}{Dedução da instância}
\vspace{2.5mm}
Pelo corolário 3.1 e pelo facto que exl,exr e dup são linerares deduzimos que:

$\mathcal{D}^{+}$ exl $\lambda$p $\rightarrow$ (exp p, exl)

$\mathcal{D}^{+}$ exr $\lambda$p $\rightarrow$ (exr p, exr)

$\mathcal{D}^{+}$ dup $\lambda$a $\rightarrow$ (dup a, dup)

Após esta dedução podemos continuar a determinar a instância:

exl = $\mathcal{D}$ ($\mathcal{D}^{+}$ exl)

exr = $\mathcal{D}$ ($\mathcal{D}^{+}$ exr)

dup = $\mathcal{D}$ ($\mathcal{D}^{+}$ dup)

\end{frame}



\begin{frame}{Dedução da instância} 
\vspace{2.5mm}
Substituindo e usando a definição de linearD obtemos:

exl = linearD exl

exr = linearD exr

dup = linearD dup

E podemos converter a dedução acima diretamente em instância:

\begin{block}{Instância da categoria que deduzimos}

instance \textit{Cartesian $\mathcal{D}$} where

\hspace{0.2cm}exl = linearD exl

\hspace{0.2cm}exr = linearD exr

\hspace{0.2cm}dup = linearD dup

\end{block}

\end{frame}



\begin{frame}{Categorias cocartesianas}
\vspace{2.5mm}
São o dual das categorias cartesianas.
\begin{block}{Nota}
Neste papel os coprodutos correspondem aos produtos das categorias, i.e., categorias de biprodutos.
\end{block}

\begin{block}

class \textit{Category k} $\Rightarrow$ \textit{Cocartesian k} where:

\hspace{0.2cm}inl :: a'k'(a$\times$b)

\hspace{0.2cm}inlr:: b'k'(a$\times$b)

\hspace{0.2cm}jam :: (a$\times$a)'k'a

\end{block}


\end{frame}


\begin{frame}{Functores cocartesianos}
\vspace{2.5mm}
\begin{block}{Definição de functor cocartesiano}


Um functor \textit{F} cartesiano entre categorias $\mathcal{U}$ e $\mathcal{V}$ é tal que:
\begin{itemize}
\item \textit{F} é functor 
\item \textit{F} inl = inl
\item \textit{F} inr = inr
\item \textit{F} jam = jam
\end{itemize}


\end{block}


\end{frame}









\section{Fork e Join}
\begin{frame}{Fork e Join}
\vspace{25mm}
\begin{itemize}
	\item
	$(\Delta)$ :: Cartesian k $\Rightarrow$ (a 'k' c) $\to$ (a 'k' d) $\to$ (a 'k' (c $\times$ d))
	\item
	$(\nabla)$ :: Cartesian k $\Rightarrow$ (c 'k' a) $\to$ (d 'k' a) $\to$ ((c $\times$ d) 'k' a)
\end{itemize}
\end{frame}

\begin{frame}{instancia de $\to^+$}
\vspace{2.5mm}
\textbf{newtype} a $\to^+$ b = AddFun (a $\rightarrow$ b)\\
\vspace{2mm} 
\textbf{instance} Category ($\to^+$) \textbf{where}\\
\hspace{1cm}type Obj ($\to^+$) = Additive\\
\hspace{1cm}id = AddFun id\\
\hspace{1cm}AddFun g $\circ$ AddFun f = AddFun (g $\circ$ f )\\
\vspace{2mm} 
\textbf{instance} Monoidal ($\to^+$) \textbf{where}\\
\hspace{1cm}AddFun f $\times$ AddFun g = AddFun (f $\times$ g)\\
\vspace{2mm} 
\textbf{instance} Cartesian ($\to^+$) \textbf{where}\\
\hspace{1cm}exl = AddFun exl\\
\hspace{1cm}exr = AddFun exr\\
\hspace{1cm}dup = AddFun dup\\
\end{frame}
\begin{frame}{instancia de $\to^+$}
\vspace{2.5mm}
\textbf{instance} Cocartesian ($\to^+$) \textbf{where}\\
\hspace{1cm} inl = AddFun inlF\\
\hspace{1cm} inr = AddFun inrF\\
\hspace{1cm} jam = AddFun jamF\\
\vspace{2mm} 
inlF :: Additive b $\Rightarrow$ a $\rightarrow$ a $\times$ b\\ 
inrF :: Additive a $\Rightarrow$ b $\rightarrow$ a $\times$ b\\
jamF :: Additive a $\Rightarrow$ a $\times$ a $\rightarrow$ a\\
\vspace{2mm} 
inlF = $\lambda$a $\rightarrow$ (a, 0)    \\ 
inrF = $\lambda$b $\rightarrow$ (0, b)    \\
jamF = $\lambda$(a, b) $\rightarrow$ a + b\\ 
\end{frame}

\section{Operacoes Numericas}
\begin{frame}{definição de NumCat}
\vspace{2.5mm}
\textbf{class} NumCat k a \textbf{where}\\
\hspace{1cm}negateC :: a 'k' a\\
\hspace{1cm}addC :: (a $\times$ a) 'k' a\\
\hspace{1cm}mulC :: (a $\times$ a) 'k' a\\
\hspace{1cm}...\\
\vspace{2mm} 
\textbf{instance} Num a $\Rightarrow$ NumCat ($\rightarrow$) a \textbf{where}\\
\hspace{1cm}negateC = negate\\
\hspace{1cm}addC = uncurry (+)\\
\hspace{1cm}mulC = uncurry (·)\\
\hspace{1cm}...\\
\end{frame}
\begin{frame}
\vspace{20mm}
D (negate u) = negate (D u)\\
D (u + v) = D u + D v\\
D (u · v) = u · D v + v · D u\\
\begin{itemize}
\item
Impreciso na natureza de u e v.
\item
Algo mais preciso seria defenir a diferenciação das operações em si.
\end{itemize}
\end{frame}
\begin{frame}
\vspace{2.5mm}
\textbf{class} Scalable k a \textbf{where}\\
\hspace{1cm}scale :: a $\rightarrow$ (a 'k' a)\\
\vspace{2mm} 
\textbf{instance} Num a $\Rightarrow$ Scalable ($\to^+$) a \textbf{where}\\
\hspace{1cm}scale a = AddFun ($\lambda$da $\rightarrow$ a · da)\\
\vspace{5mm} 
\textbf{instance} NumCat D \textbf{where}\\
\hspace{1cm}negateC = linearD negateC\\
\hspace{1cm}addC = linearD addC\\
\hspace{1cm}mulC = D ($\lambda$(a, b) $\rightarrow$ (a · b, scale b $\nabla$ scale a))\\
\end{frame}

\section{Exemplos}
\begin{frame}{Exemplos}
\end{frame}

\section{Generalizar AD}
\begin{frame}{Generalizar AD}
    newtype $D_k$ a b = D (a $\to$ b $\times$ (a 'k' b))\\
    \vspace{2mm} 
    linearD :: (a $\to$ b) $\to$ (a 'k' b) $\to$ $D_k$ a b\\
    linearD f f'= D ($\lambda$a $\to$ (f a, f'))\\
    \vspace{2mm} 
    \textbf{instance} Category k $\to$ Category $D_k$ \textbf{where}\\
        \hspace{1cm}type Obj $D_k$ = Additive $\wedge$ Obj k ...\\
    \vspace{2mm} 
    \textbf{instance} Monoidal k $\Rightarrow$ Monoidal $D_k$ \textbf{where} ...\\
    \vspace{2mm} 
    \textbf{instance} Cartesian k $\Rightarrow$ Cartesian $D_k$ \textbf{where} ...\\
    \vspace{2mm} 
    \textbf{instance} Cocartesian k $\Rightarrow$ Cocartesian $D_k$ \textbf{where}\\
        \hspace{1cm}inl = linearD inlF inl\\
        \hspace{1cm}inr = linearD inrF inr\\
        \hspace{1cm}jam = linearD jamF jam\\
    \vspace{2mm} 
    \textbf{instance} Scalable k s $\Rightarrow$ NumCat $D_k$ s \textbf{where}\\
        \hspace{1cm}negateC = linearD negateC negateC\\
        \hspace{1cm}addC = linearD addC addC\\
        \hspace{1cm}mulC = D ($\lambda$(a, b) $\to$ (a · b, scale b $\nabla$ scale a))\\
\end{frame}

%============================EXEMPLO==========================
%\section{Introduction}
%
%\subsection[Short First Subsection Name]{First Subsection Name}
%
%\begin{frame}{Make Titles Informative. Use Uppercase Letters.}{Subtitles are optional.}
%  % - A title should summarize the slide in an understandable fashion
%  %   for anyone how does not follow everything on the slide itself.
%
%  \begin{itemize}
%  \item
%    Use \texttt{itemize} a lot.
%  \item
%    Use very short sentences or short phrases.
%  \end{itemize}
%\end{frame}
%
%\begin{frame}{Make Titles Informative.}
%
%  You can create overlays\dots
%  \begin{itemize}
%  \item using the \texttt{pause} command:
%    \begin{itemize}
%    \item
%      First item.
%      \pause
%    \item    
%      Second item.
%    \end{itemize}
%  \item
%    using overlay specifications:
%    \begin{itemize}
%    \item<3->
%      First item.
%    \item<4->
%      Second item.
%    \end{itemize}
%  \item
%    using the general \texttt{uncover} command:
%    \begin{itemize}
%      \uncover<5->{\item
%        First item.}
%      \uncover<6->{\item
%        Second item.}
%    \end{itemize}
%  \end{itemize}
%\end{frame}
%
%\begin{frame}{}
%\end{frame}
%
%\subsection{Second Subsection}
%
%\begin{frame}{Make Titles Informative.}
%\end{frame}
%
%
%
%\section{Summary}
%
%\subsection{coisas1}
%
%\begin{frame}{Summary}
%
%  % Keep the summary *very short*.
%  \begin{itemize}
%  \item
%    The \alert{first main message} of your talk in one or two lines.
%  \item
%    The \alert{second main message} of your talk in one or two lines.
%  \item
%    Perhaps a \alert{third message}, but not more than that.
%  \end{itemize}
%  
%  % The following outlook is optional.
%  \vskip0pt plus.5fill
%  \begin{itemize}
%  \item
%    Outlook
%    \begin{itemize}
%    \item
%      Something you haven't solved.
%    \item
%      Something else you haven't solved.
%    \end{itemize}
%  \end{itemize}
%\end{frame}
%
%\subsection{coisas2}
%\begin{frame}{coisas2}
%
%
%\end{frame}
%=================================================================

\end{document}

\documentclass{beamer}

\mode<presentation>
{
  \usetheme{JuanLesPins}

  \setbeamercovered{transparent}
}


\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
%\usepackage[latin1]{inputenc}

\usepackage{times}
\usepackage[T1]{fontenc}
% Note that the encoding and the font should match. If T1
% does not look nice, try deleting the line with the fontenc.
\usepackage[all]{xy}

\newtheorem{teor}{Theorem}[section]
\newtheorem{coro}{Corollary}[section]
\theoremstyle{definition}
\newtheorem{defi}{Definition}[section]
\theoremstyle{definition}
\newtheorem{exemplo}{example}[section]
\theoremstyle{theorem}
\newtheorem{propo}{Proposicion}[section]
\newtheorem{nota}{Note}[section]
\def\N{\mathbb{N}}
\def\R{\mathbb{R}}
\def\C{\mathbb{C}}
\newcommand{\norm}[1]{\left\lVert#1\right\rVert}

%---------- lhs2tex ---------------------------------
%% ODER: format ==         = "\mathrel{==}"
%% ODER: format /=         = "\neq "
%
%
\makeatletter
\@ifundefined{lhs2tex.lhs2tex.sty.read}%
  {\@namedef{lhs2tex.lhs2tex.sty.read}{}%
   \newcommand\SkipToFmtEnd{}%
   \newcommand\EndFmtInput{}%
   \long\def\SkipToFmtEnd#1\EndFmtInput{}%
  }\SkipToFmtEnd

\newcommand\ReadOnlyOnce[1]{\@ifundefined{#1}{\@namedef{#1}{}}\SkipToFmtEnd}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{stmaryrd}
\DeclareFontFamily{OT1}{cmtex}{}
\DeclareFontShape{OT1}{cmtex}{m}{n}
  {<5><6><7><8>cmtex8
   <9>cmtex9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmtex10}{}
\DeclareFontShape{OT1}{cmtex}{m}{it}
  {<-> ssub * cmtt/m/it}{}
\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
  {<5><6><7><8>cmtt8
   <9>cmbtt9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmbtt10}{}
\DeclareFontShape{OT1}{cmtex}{bx}{n}
  {<-> ssub * cmtt/bx/n}{}
\newcommand{\tex}[1]{\text{\texfamily#1}}	% NEU

\newcommand{\Sp}{\hskip.33334em\relax}


\newcommand{\Conid}[1]{\mathit{#1}}
\newcommand{\Varid}[1]{\mathit{#1}}
\newcommand{\anonymous}{\kern0.06em \vbox{\hrule\@width.5em}}
\newcommand{\plus}{\mathbin{+\!\!\!+}}
\newcommand{\bind}{\mathbin{>\!\!\!>\mkern-6.7mu=}}
\newcommand{\rbind}{\mathbin{=\mkern-6.7mu<\!\!\!<}}% suggested by Neil Mitchell
\newcommand{\sequ}{\mathbin{>\!\!\!>}}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\usepackage{polytable}

%mathindent has to be defined
\@ifundefined{mathindent}%
  {\newdimen\mathindent\mathindent\leftmargini}%
  {}%

\def\resethooks{%
  \global\let\SaveRestoreHook\empty
  \global\let\ColumnHook\empty}
\newcommand*{\savecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\savecolumns[#1]}}
\newcommand*{\restorecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\restorecolumns[#1]}}
\newcommand*{\aligncolumn}[2]%
  {\g@addto@macro\ColumnHook{\column{#1}{#2}}}

\resethooks

\newcommand{\onelinecommentchars}{\quad-{}- }
\newcommand{\commentbeginchars}{\enskip\{-}
\newcommand{\commentendchars}{-\}\enskip}

\newcommand{\visiblecomments}{%
  \let\onelinecomment=\onelinecommentchars
  \let\commentbegin=\commentbeginchars
  \let\commentend=\commentendchars}

\newcommand{\invisiblecomments}{%
  \let\onelinecomment=\empty
  \let\commentbegin=\empty
  \let\commentend=\empty}

\visiblecomments

\newlength{\blanklineskip}
\setlength{\blanklineskip}{0.66084ex}

\newcommand{\hsindent}[1]{\quad}% default is fixed indentation
\let\hspre\empty
\let\hspost\empty
\newcommand{\NB}{\textbf{NB}}
\newcommand{\Todo}[1]{$\langle$\textbf{To do:}~#1$\rangle$}

\EndFmtInput
\makeatother
%
%
%
%
%
%
% This package provides two environments suitable to take the place
% of hscode, called "plainhscode" and "arrayhscode". 
%
% The plain environment surrounds each code block by vertical space,
% and it uses \abovedisplayskip and \belowdisplayskip to get spacing
% similar to formulas. Note that if these dimensions are changed,
% the spacing around displayed math formulas changes as well.
% All code is indented using \leftskip.
%
% Changed 19.08.2004 to reflect changes in colorcode. Should work with
% CodeGroup.sty.
%
\ReadOnlyOnce{polycode.fmt}%
\makeatletter

\newcommand{\hsnewpar}[1]%
  {{\parskip=0pt\parindent=0pt\par\vskip #1\noindent}}

% can be used, for instance, to redefine the code size, by setting the
% command to \small or something alike
\newcommand{\hscodestyle}{}

% The command \sethscode can be used to switch the code formatting
% behaviour by mapping the hscode environment in the subst directive
% to a new LaTeX environment.

\newcommand{\sethscode}[1]%
  {\expandafter\let\expandafter\hscode\csname #1\endcsname
   \expandafter\let\expandafter\endhscode\csname end#1\endcsname}

% "compatibility" mode restores the non-polycode.fmt layout.

\newenvironment{compathscode}%
  {\par\noindent
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed\)%
   \par\noindent
   \ignorespacesafterend}

\newcommand{\compaths}{\sethscode{compathscode}}

% "plain" mode is the proposed default.
% It should now work with \centering.
% This required some changes. The old version
% is still available for reference as oldplainhscode.

\newenvironment{plainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newenvironment{oldplainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

% Here, we make plainhscode the default environment.

\newcommand{\plainhs}{\sethscode{plainhscode}}
\newcommand{\oldplainhs}{\sethscode{oldplainhscode}}
\plainhs

% The arrayhscode is like plain, but makes use of polytable's
% parray environment which disallows page breaks in code blocks.

\newenvironment{arrayhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\parray}%
  {\endparray\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newcommand{\arrayhs}{\sethscode{arrayhscode}}

% The mathhscode environment also makes use of polytable's parray 
% environment. It is supposed to be used only inside math mode 
% (I used it to typeset the type rules in my thesis).

\newenvironment{mathhscode}%
  {\parray}{\endparray}

\newcommand{\mathhs}{\sethscode{mathhscode}}

% texths is similar to mathhs, but works in text mode.

\newenvironment{texthscode}%
  {\(\parray}{\endparray\)}

\newcommand{\texths}{\sethscode{texthscode}}

% The framed environment places code in a framed box.

\def\codeframewidth{\arrayrulewidth}
\RequirePackage{calc}

\newenvironment{framedhscode}%
  {\parskip=\abovedisplayskip\par\noindent
   \hscodestyle
   \arrayrulewidth=\codeframewidth
   \tabular{@{}|p{\linewidth-2\arraycolsep-2\arrayrulewidth-2pt}|@{}}%
   \hline\framedhslinecorrect\\{-1.5ex}%
   \let\endoflinesave=\\
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \framedhslinecorrect\endoflinesave{.5ex}\hline
   \endtabular
   \parskip=\belowdisplayskip\par\noindent
   \ignorespacesafterend}

\newcommand{\framedhslinecorrect}[2]%
  {#1[#2]}

\newcommand{\framedhs}{\sethscode{framedhscode}}

% The inlinehscode environment is an experimental environment
% that can be used to typeset displayed code inline.

\newenvironment{inlinehscode}%
  {\(\def\column##1##2{}%
   \let\>\undefined\let\<\undefined\let\\\undefined
   \newcommand\>[1][]{}\newcommand\<[1][]{}\newcommand\\[1][]{}%
   \def\fromto##1##2##3{##3}%
   \def\nextline{}}{\) }%

\newcommand{\inlinehs}{\sethscode{inlinehscode}}

% The joincode environment is a separate environment that
% can be used to surround and thereby connect multiple code
% blocks.

\newenvironment{joincode}%
  {\let\orighscode=\hscode
   \let\origendhscode=\endhscode
   \def\endhscode{\def\hscode{\endgroup\def\@currenvir{hscode}\\}\begingroup}
   %\let\SaveRestoreHook=\empty
   %\let\ColumnHook=\empty
   %\let\resethooks=\empty
   \orighscode\def\hscode{\endgroup\def\@currenvir{hscode}}}%
  {\origendhscode
   \global\let\hscode=\orighscode
   \global\let\endhscode=\origendhscode}%

\makeatother
\EndFmtInput
%
%----------------------------------------------------

\newenvironment{slide}[1]{\begin{frame}\frametitle{#1}}{\end{frame}}

\title
{Simple essence of AD}

\author[Artur, Ezequiel, Nelson] 
{Artur \and Ezequiel \and Nelson}

\institute
{Universidade do Minho}

\date
{26 de Abril}

\subject{Talks}

% If you have a file called "university-logo-filename.xxx", where xxx
% is a graphic format that can be processed by latex or pdflatex,
% resp., then you can add a logo as follows:

% \pgfdeclareimage[height=0.5cm]{university-logo}{university-logo-filename}
% \logo{\pgfuseimage{university-logo}}

% Delete this, if you do not want the table of contents to pop up at
% the beginning of each subsection:

\AtBeginSubsection[]
{
  \begin{frame}<beamer>{Outline}
    \tableofcontents[currentsection,currentsubsection]
  \end{frame}
}


% If you wish to uncover everything in a step-wise fashion, uncomment
% the following command: 

%\beamerdefaultoverlayspecification{<+->}


\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}{Index}
  \tableofcontents
\end{frame}

% - Exactly two or three sections (other than the summary).
% - At *most* three subsections per section.
% - Talk about 30s to 2min per frame. So there should be between about
%   15 and 30 frames, all told.

%Ne1

\begin{frame}
\frametitle{Definition of Derivative}
\vspace{5mm}

\begin{defi}
		Let $f:\R \to \R$ be a function. The derivative of $f$ at point $x \in \R$ is defined the following way:
	\begin{align*}
	\textit{$f $$'$ $(x)$} = \ \lim_{\varepsilon \to 0} \frac{\textit{$f$($x$ $+$ $\varepsilon$) - $f(x)$}}{\varepsilon}
	\end{align*}
\end{defi}
\vspace{5mm}
\pause
This definition will also work with functions of types $\C \hspace{0.5mm}\to \C$ and $\R\hspace{0.6mm} \to \R^{n}$.

\end{frame}
%%%
\begin{frame}
\frametitle{Definition of Derivative}
\vspace{10mm}
For functions $F$ of types $\R^{m}\hspace{-0.3mm} \to \R$ and $\R^{m}\hspace{-0.3mm}\to \R^{n}$ (with $n>1$), we need a different definition.
\pause
\vspace{1mm}
    \begin{itemize}
    \item  For functions of type $\R^{m}\hspace{-0.3mm} \to \R$, it is necessary the introduction of the notion of parcial derivatives, $\frac{\partial F}{\partial x_{j}}\hspace{0.3mm}$, with $j \in$ \{$1,...,m$\}.
    
    \pause
    \vspace{3mm}
    \item For functions of type $\R^{m}\hspace{-0.3mm}\to \R^{n}$ (with $n>1$), apart from the use of parcial derivatives, it is necessary the use of Jacobian matrices $\mathbf{J}_{i,j} =\frac{\partial F_{i}}{\partial x_{j}}$, where $i \in$ \{$1,...,n$\} and $F_{i}$ is a function $\R^{m}\hspace{-0.3mm}\to \R$.
    \end{itemize} 
\end{frame}
%%%
\begin{frame}
\frametitle{Generalization and Chain Rule}
\vspace{15mm}
Let $\mathbf{A}$ and $\mathbf{B}$ be two Jacobian matrices. 

The chain rule in $\R^{m}\hspace{-0.3mm}\to \R^{n}$ is:
\begin{align*}
(\mathbf{A} \cdotp \mathbf{B})_{i,j}= \sum_{k=1}^{m} \mathbf{A}_{i,k} \cdotp \mathbf{B}_{k,j}
\end{align*}
\end{frame}
%%%
\begin{frame}
\frametitle{Generalization and Chain Rule}
\vspace{15mm}
Assuming that the notion of derivatives that we need matches with a linear map, where it is accepted the chain rule previously seen, we will define a new generalization:
\pause

\begin{align*}
\hspace{-2mm} \lim_{\varepsilon \to 0} \frac{\textit{$f$($x$ $+$ $\varepsilon$) - $f(x)$}}{\varepsilon} - \textit{$f $$'$ $(x)$} = 0 \hspace{0.5mm} 
\Leftrightarrow \hspace{0.5mm} \lim_{\varepsilon \to 0} \frac{\textit{$f$($x$ $+$ $\varepsilon$) - ($f(x)$)} + \varepsilon \cdotp \textit{$f $$'$ $(x)$}}{\varepsilon} = 0 \\
& 
\hspace{-6.6cm}  \Leftrightarrow  
\lim_{\varepsilon \to 0} 
\frac{
\norm{ \textit{$f$($x$ $+$ $\varepsilon$) - ($f(x)$)} + \varepsilon \cdotp \textit{$f'(x)$} } 
}{
\norm{ \varepsilon }
} 
= 0
\end{align*}

\end{frame}
%%%
\begin{frame}
\begin{center}
	\frametitle{Derivate as a linear map} 
\end{center}
\begin{defi}
	Let $f::a \to b$ be a function, where $a$ and $b$ are vectorial spaces that share a common underlying field. The first derivative definition is the following:
	\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[9]{}\mathcal{D}\mathbin{::}(\Varid{a}\rightarrow \Varid{b})\rightarrow (\Varid{a}\rightarrow (\Varid{a}\;\multimap \;\Varid{b})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
    If we differentiate two times, we have:
    \begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{6}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[6]{}\mathcal{D}^{2}\mathrel{=}\mathcal{D}\mathbin{\circ}\mathcal{D}\mathbin{::}(\Varid{a}\rightarrow \Varid{b})\rightarrow (\Varid{a}\rightarrow (\Varid{a}\;\multimap \;\Varid{a}\;\multimap \;\Varid{b})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{defi}

\end{frame}

\begin{frame}
\frametitle{Rules for Differentiation - Sequential Composition}
\vspace{15mm}
\begin{teor}
	
	Let $f:: a \to b$ and $g:: b \to c$ be two functions. Then the derivative of the composition of $f$ and $g$ is:
	\begin{align*}
	\mathcal{D} \ (g \circ f ) \ a= \mathcal{D} \hspace{0.9mm} g \hspace{1.0mm}  (f \hspace{0.5mm} a)   \hspace{0.6mm} \circ \hspace{0.6mm} \mathcal{D} \hspace{0.6mm} f \ a
	\end{align*}
\end{teor}
\end{frame}
\begin{frame}
\frametitle{Rules for Differentiation - Sequential Composition}
Unfortunately the previous theorem isn't a efficient recipe for composition. As such we will introduce a second derivative definition:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathcal{D}^{+}_{0}\mathbin{::}(\Varid{a}\rightarrow \Varid{b})\rightarrow ((\Varid{a}\rightarrow \Varid{b}) \times (\Varid{a}\rightarrow (\Varid{a}\;\multimap \;\Varid{b}))){}\<[E]%
\\
\>[B]{}\mathcal{D}^{+}_{0}\;\Varid{f}\mathrel{=}(\Varid{f},\mathcal{D}\;\Varid{f}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\pause

With this, the chain rule will have the following expression:

$\mathcal{D}_{0}^{+} \hspace{0.5mm} (g \circ f) $ 

\{definition of $\mathcal{D}_{0}^{+}$\}\\
$= (g \circ f,\hspace{0.2mm} \mathcal{D} \hspace{0.5mm} (g \circ f) \hspace{0.5mm})$ \hspace{3.3cm} \\
\{theorem and definition of $g \circ f$\}\\

$= (\lambda a \to g (f \hspace{0.5mm} a),\hspace{0.2mm} \lambda a \to \mathcal{D} \hspace{0.9mm} g \hspace{1.0mm}  (f \hspace{0.5mm} a)   \hspace{0.5mm} \circ \hspace{0.5mm} \mathcal{D} \hspace{0.5mm} f \hspace{0.5mm} a )$ \hspace{1.5mm} \\
\end{frame}
\begin{frame}
\frametitle{Rules for Differentiation - Sequential Composition} 
Having in mind optimizations, we introduce the third and last derivative definition:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathcal{D}^{+}\mathbin{::}(\Varid{a}\rightarrow \Varid{b})\rightarrow (\Varid{a}\rightarrow (\Varid{b} \times (\Varid{a}\;\multimap \;\Varid{b}))){}\<[E]%
\\
\>[B]{}\mathcal{D}^{+}\;\Varid{f}\;\Varid{a}\mathrel{=}(\Varid{f}\;\Varid{a},\mathcal{D}\;\Varid{f}\;\Varid{a}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\pause

As $\times$ has more priority than $\to$ and $\multimap$, we can rewrite $\mathcal{D}^{+} $ as:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathcal{D}^{+}\mathbin{::}(\Varid{a}\rightarrow \Varid{b})\rightarrow (\Varid{a}\rightarrow \Varid{b} \times (\Varid{a}\;\multimap \;\Varid{b})){}\<[E]%
\\
\>[B]{}\mathcal{D}^{+}\;\Varid{f}\;\Varid{a}\mathrel{=}(\Varid{f}\;\Varid{a},\mathcal{D}\;\Varid{f}\;\Varid{a}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{frame}

\begin{frame}
\frametitle{Rules for Differentiation - Sequential Composition} 
\begin{coro}
	$\mathcal{D}^{+}$ is efficiently compositional in relation to $(\circ)$, that is, in Haskell:
	\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[9]{}\mathcal{D}^{+}\;(\Varid{g}\mathbin{\circ}\Varid{f})\;\Varid{a}\mathrel{=}\mathbf{let}\;\{\mskip1.5mu (\Varid{b},\Varid{f'})\mathrel{=}\mathcal{D}^{+}\;\Varid{f}\;\Varid{a};(\Varid{c},\Varid{g'})\mathrel{=}\mathcal{D}^{+}\;\Varid{g}\;\Varid{b}\mskip1.5mu\}{}\<[E]%
\\
\>[9]{}\hsindent{4}{}\<[13]%
\>[13]{}\mathbf{in}\;(\Varid{c},\Varid{g'}\mathbin{\circ}\Varid{f'}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{coro}
\vspace{-3mm}

\begin{eqnarray*}
\xymatrix@C=4em{
  \ensuremath{{({\Conid{C}}\times \Conid{C}^{\Conid{B}})}\times \Conid{B}^{\Conid{A}}}
      \ar[d]_-{\ensuremath{(\Varid{id} \times (\Varid{uncurry}\;(\mathbin{\circ})))\mathbin{\circ}\Varid{assocr}}}
&
  \ensuremath{{\Conid{B}}\times \Conid{B}^{\Conid{A}}}
      \ar[l]_-{\ensuremath{{\cal D}^+ \Varid{g} \times \Varid{id}}}
&
  \ensuremath{\Conid{A}}
      \ar[l]_-{\ensuremath{{\cal D}^+ \Varid{f}}}
      \ar[dll]^-{\ensuremath{{\cal D}^+ (\Varid{g}\mathbin{\circ}\Varid{f})}}
\\
  \ensuremath{{\Conid{C}}\times \Conid{C}^{\Conid{A}}}
}
\end{eqnarray*}
\end{frame}

\begin{frame}
\frametitle{Rules for Differentiation - Parallel Composition} 
\vspace{10mm}
Another important way of combining functions is the operation cross, that combines two functions in parallel:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}( \times )\mathbin{::}(\Varid{a}\rightarrow \Varid{c})\rightarrow (\Varid{b}\rightarrow \Varid{d})\rightarrow (\Varid{a} \times \Varid{b}\rightarrow \Varid{c} \times \Varid{d}){}\<[E]%
\\
\>[B]{}\Varid{f} \times \Varid{g}\mathrel{=}\lambda (\Varid{a},\Varid{b})\rightarrow (\Varid{f}\;\Varid{a},\Varid{g}\;\Varid{b}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\pause
\begin{teor}	
	Let $f :: a \to c$ and $g :: b \to d$ be two function. Then the cross rule is the following:
	\begin{align*}
	\mathcal{D} \hspace{0.5mm} (f \boldsymbol{\times} g) \hspace{0.5mm} (a,\hspace{0.2mm} b) = \mathcal{D} \hspace{0.5mm} f \hspace{0.9mm} a \boldsymbol{\times} \mathcal{D} \hspace{0.5mm} g \hspace{0.9mm} b
	\end{align*}
\end{teor}
\end{frame}
%%%
\begin{frame}
\frametitle{Rules for Differentiation - Parallel Composition} 
\vspace{15mm}
\begin{coro}
	The function $\mathcal{D}^{+}$ is compositional in relation to $(\boldsymbol{\times})$
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[9]{}\mathcal{D}^{+}\;(\Varid{f} \times \Varid{g})\;(\Varid{a},\Varid{b})\mathrel{=}\mathbf{let}\;\{\mskip1.5mu (\Varid{c},\Varid{f'})\mathrel{=}\mathcal{D}^{+}\;\Varid{f}\;\Varid{a};(\Varid{d},\Varid{g'})\mathrel{=}\mathcal{D}^{+}\;\Varid{g}\;\Varid{b}\mskip1.5mu\}{}\<[E]%
\\
\>[9]{}\hsindent{4}{}\<[13]%
\>[13]{}\mathbf{in}\;((\Varid{c},\Varid{d}),\Varid{f'} \times \Varid{g'}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{coro}
\end{frame}
%%%
\begin{frame}
\frametitle{Derivative and Linear Functions} 
\vspace{5mm}
\begin{defi}
	A function $f$ is said to be linear when preserves addition and scalar multiplication.
	\vspace{2mm}
	
	\hspace{5mm} $f(a + a')= f \hspace{0.5mm} a + f \hspace{0.5mm} a'$
	
	\vspace{1mm}
	\hspace{5mm} $f(s \cdot a)= s \cdot f \hspace{0.5mm} a$

\end{defi}
\pause
\vspace{4mm}
\begin{teor}
	For all linear functions $f$, $\mathcal{D} \hspace{0.5mm} f \hspace{0.9mm} a = f $.
\end{teor}
\pause
\vspace{2mm}
\begin{coro}
	For all linear functions  $f$, $\mathcal{D}^{+} \hspace{0.5mm} f = \lambda a \to (fa,\hspace{0.5mm} f)$.

\end{coro}
\end{frame}

%Ez1
\section{Categories}

\begin{frame}{A short introdution}
\begin{itemize}
 \item<1-> We want to calculate \ensuremath{\mathcal{D}^{+}}.
 \item<2-> However, \ensuremath{\mathcal{D}} is not computable.
 \item<3-> Solution: reimplement corollaries using category theory
\end{itemize}

\end{frame}



\begin{frame}{A short introdution}

    \begin{block}{Corollary 1.1}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[9]{}\mathcal{D}^{+}\;(\Varid{g}\mathbin{\circ}\Varid{f})\;\Varid{a}\mathrel{=}\mathbf{let}\;\{\mskip1.5mu (\Varid{b},\Varid{f'})\mathrel{=}\mathcal{D}^{+}\;\Varid{f}\;\Varid{a};(\Varid{c},\Varid{g'})\mathrel{=}\mathcal{D}^{+}\;\Varid{g}\;\Varid{b}\mskip1.5mu\}{}\<[E]%
\\
\>[9]{}\hsindent{4}{}\<[13]%
\>[13]{}\mathbf{in}\;(\Varid{c},\Varid{g'}\mathbin{\circ}\Varid{f'}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
    \end{block}
    
    \begin{block}{Corollary 2.1}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[9]{}\mathcal{D}^{+}\;(\Varid{f} \times \Varid{g})\;(\Varid{a},\Varid{b})\mathrel{=}\mathbf{let}\;\{\mskip1.5mu (\Varid{c},\Varid{f'})\mathrel{=}\mathcal{D}^{+}\;\Varid{f}\;\Varid{a};(\Varid{d},\Varid{g'})\mathrel{=}\mathcal{D}^{+}\;\Varid{g}\;\Varid{b}\mskip1.5mu\}{}\<[E]%
\\
\>[9]{}\hsindent{4}{}\<[13]%
\>[13]{}\mathbf{in}\;((\Varid{c},\Varid{d}),\Varid{f'} \times \Varid{g'}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
    \end{block}
    
    \begin{block}{Corollary 3.1}
	For all linear functions  $f$, $\mathcal{D}^{+} \hspace{0.5mm} f = \lambda a \to (fa,\hspace{0.5mm} f)$.
    \end{block}
 
\end{frame}




\begin{frame}{Categories}

A category is a collection of objects (sets and types) and morphisms(operation between objects),
with 2 basic operations (identity and composition) of morfisms, and 2 laws:

\begin{itemize}
    \item (C.1)  $id \circ f = f \circ id = f$
    \item (C.2)  $f \circ (g \circ h) = (f \circ g) \circ h$
\end{itemize}

\begin{block}{Note}
For this paper, objects are data types and morfisms are functions
\end{block}

\begin{columns}
\begin{column}{0.6\textwidth}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{class}\;\Conid{Category}\;\Varid{k}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{id}\mathbin{::}(\Varid{a'k'a}){}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}(\mathbin{\circ})\mathbin{::}(\Varid{b'k'c})\rightarrow (\Varid{a'k'b})\rightarrow (\Varid{a'k'c}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{column}

\begin{column}{0.6\textwidth}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{instance}\;\Conid{Category}\;(\rightarrow )\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{id}\mathrel{=}\lambda \Varid{a}\rightarrow \Varid{a}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{g}\mathbin{\circ}\Varid{f}\mathrel{=}\lambda \Varid{a}\rightarrow \Varid{g}\;(\Varid{f}\;\Varid{a}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{column}
\end{columns}
\end{frame}




\begin{frame}{Functors}

A functor F between 2 categories \ensuremath{\mathcal{U}\;\Varid{and}\;\mathcal{V}} is such that:
\begin{itemize}
    \item given any object t $\in$ \ensuremath{\mathcal{U}} there exists an object F t $\in$ \ensuremath{\mathcal{V}}
    \item given any morphism m :: a \ensuremath{\rightarrow } b $\in$ \ensuremath{\mathcal{U}} there exists a morphism F m :: F a \ensuremath{\rightarrow } F b $\in$ \ensuremath{\mathcal{V}}
    \item F id ($\in$ \ensuremath{\mathcal{U}}) = id ($\in$ \ensuremath{\mathcal{V}})
    \item F (f $\circ$ g) = F f $\circ$ F g
\end{itemize}

\begin{block}{Note}
Given this papers category properties (objects are data types) functors map types to themselves
\end{block}

\end{frame}



\begin{frame}{Objective}
\begin{block}{\ensuremath{\mathcal{D}} definition}
\ensuremath{\mathbf{newtype}\;\mathcal{D}\;\Varid{a}\;\Varid{b}\mathrel{=}\mathcal{D}\;(\Varid{a}\rightarrow \Varid{b} \times (\Varid{a}\;\multimap \;\Varid{b}))}
\end{block}
\begin{block}{Adapted definition for \ensuremath{\mathcal{D}} type}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathcal{\hat{D}}\mathbin{::}(\Varid{a}\rightarrow \Varid{b})\rightarrow \mathcal{D}\;\Varid{a}\;\Varid{b}{}\<[E]%
\\
\>[B]{}\mathcal{\hat{D}}\;\Varid{f}\mathrel{=}\mathcal{D}\;(\mathcal{D}^{+}\;\Varid{f}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{block}

Our objective is to deduce an instance of a Category for \ensuremath{\mathcal{D}} where \ensuremath{\mathcal{\hat{D}}} is a functor.

\end{frame}




\begin{frame}{Instance deduction}

Using corollaries 3.1 and 1.1 we can determine that

\begin{itemize}
    \item (DP.1) \ensuremath{\mathcal{D}^{+}\;\Varid{id}\mathrel{=}\lambda \Varid{a}\rightarrow (\Varid{id}\;\Varid{a},\Varid{id})}
    \item (DP.2)    
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[5]{}\mathcal{D}^{+}\;(\Varid{g}\mathbin{\circ}\Varid{f})\mathrel{=}\lambda \Varid{a}\rightarrow \mathbf{let}\;\{\mskip1.5mu (\Varid{b},\Varid{f'})\mathrel{=}\mathcal{D}^{+}\;\Varid{f}\;\Varid{a};(\Varid{c},\Varid{g'})\mathrel{=}\mathcal{D}^{+}\;\Varid{g}\;\Varid{b}\mskip1.5mu\}{}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\mathbf{in}\;(\Varid{c},\Varid{g'}\mathbin{\circ}\Varid{f'}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{itemize}

Saying that \ensuremath{\mathcal{\hat{D}}} is a functor is equivalent to, for all f and g functions of apropriate types:

    \ensuremath{\Varid{id}\mathrel{=}\mathcal{\hat{D}}\;\Varid{id}\mathrel{=}\mathcal{D}\;(\mathcal{D}^{+}\;\Varid{id})}

    \ensuremath{\mathcal{\hat{D}}\;\Varid{g}\mathbin{\circ}\mathcal{\hat{D}}\;\Varid{f}\mathrel{=}\mathcal{\hat{D}}\;(\Varid{g}\mathbin{\circ}\Varid{f})\mathrel{=}\mathcal{D}\;(\mathcal{\hat{D}}\;(\Varid{g}\mathbin{\circ}\Varid{f}))}


\end{frame}



\begin{frame}{Instance deduction}

Based on  (DP.1) and (DP.2) we'll rewrite the above into the following definition:

\ensuremath{\Varid{id}\mathrel{=}\mathcal{D}\;(\lambda \Varid{a}\rightarrow (\Varid{id}\;\Varid{a},\Varid{id}))}

\ensuremath{\mathcal{\hat{D}}\;\Varid{g}\mathbin{\circ}\mathcal{\hat{D}}\;\Varid{f}\mathrel{=}\mathcal{D}\;(\lambda \Varid{a}\rightarrow \mathbf{let}\;\{\mskip1.5mu (\Varid{b},\Varid{f'})\mathrel{=}\mathcal{D}^{+}\;\Varid{f}\;\Varid{a};(\Varid{c},\Varid{g'})\mathrel{=}\mathcal{D}^{+}\;\Varid{g}\;\Varid{b}\mskip1.5mu\}\;\mathbf{in}\;(\Varid{c},\Varid{g'}\mathbin{\circ}\Varid{f'}))}
\vspace{5mm}

\pause
The first equation shown above has a trivial solution.
\vspace{3mm}

\pause
To solve the second we'll first solve a more general one:

\ensuremath{\mathcal{D}\;\Varid{g}\mathbin{\circ}\mathcal{D}\;\Varid{f}\mathrel{=}\mathcal{D}\;(\lambda \Varid{a}\rightarrow \mathbf{let}\;\{\mskip1.5mu (\Varid{b},\Varid{f'})\mathrel{=}\Varid{f}\;\Varid{a};(\Varid{c},\Varid{g'})\mathrel{=}\Varid{g}\;\Varid{b}\mskip1.5mu\}\;\mathbf{in}\;(\Varid{c},\Varid{g'}\mathbin{\circ}\Varid{f'}))}

This condition also leads us to a trivial solution inside our instance.

\end{frame}





\begin{frame}{Instance deduction}

\begin{block}{ \ensuremath{\mathcal{\hat{D}}} definition for linear functions}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{linearD}\mathbin{::}(\Varid{a}\rightarrow \Varid{b})\rightarrow \mathcal{D}\;\Varid{a}\;\Varid{b}{}\<[E]%
\\
\>[B]{}\Varid{linearD}\;\Varid{f}\mathrel{=}\mathcal{D}\;(\lambda \Varid{a}\rightarrow (\Varid{f}\;\Varid{a},\Varid{f})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{block}


\begin{block}{Categorical instance we've deduced}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{instance}\;\Conid{Category}\;\mathcal{D}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{id}\mathrel{=}\Varid{linearD}\;\Varid{id}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\mathcal{D}\;\Varid{g}\mathbin{\circ}\mathcal{D}\;\Varid{f}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\mathcal{D}\;(\lambda \Varid{a}\rightarrow \mathbf{let}\;\{\mskip1.5mu (\Varid{b},\Varid{f'})\mathrel{=}\Varid{f}\;\Varid{a};(\Varid{c},\Varid{g'})\mathrel{=}\Varid{g}\;\Varid{b}\mskip1.5mu\}\;\mathbf{in}\;(\Varid{c},\Varid{g'}\mathbin{\circ}\Varid{f'})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{block}
\end{frame}




\begin{frame}{Instance proof}

In order to prove that the instance is correct we must check if it follows laws (C.1) and (C.2).

First we must make a concession: that we only use morfisms arising from \ensuremath{\mathcal{D}^{+}}.
If we do, then \ensuremath{\mathcal{D}^{+}} is a functor.


\begin{block}{(C.1) proof}

id $\circ$ \ensuremath{\mathcal{\hat{D}}} f \\
\{ functor law for id (specification of \ensuremath{\mathcal{\hat{D}}}) \}\\
= \ensuremath{\mathcal{\hat{D}}} id $\circ$ \ensuremath{\mathcal{\hat{D}}} f \\
\{ functor law for ($\circ$) \}\\
= \ensuremath{\mathcal{\hat{D}}} (id $\circ$ f) \\
\{ categorical law \}\\
= \ensuremath{\mathcal{\hat{D}}} f 
\end{block}

\end{frame}


\begin{frame}{Instance proof}

\begin{block}{(C.2) proof}

\ensuremath{\mathcal{\hat{D}}} h $\circ$ (\ensuremath{\mathcal{\hat{D}}} g $\circ$ \ensuremath{\mathcal{\hat{D}}} f)\\
\{ 2x functor law for ($\circ$) \}\\
= \ensuremath{\mathcal{\hat{D}}} (h $\circ$ (g $\circ$ f))\\ 
\{ categorical law \}\\
= \ensuremath{\mathcal{\hat{D}}} ((h $\circ$ g) $\circ$ f)\\
\{ 2x functor law for ($\circ$) \}\\
= (\ensuremath{\mathcal{\hat{D}}} h $\circ$ \ensuremath{\mathcal{\hat{D}}} g) $\circ$ \ensuremath{\mathcal{\hat{D}}} f 

\end{block}

\begin{alertblock}{Note}
This proofs don't require anything from \ensuremath{\mathcal{D}\;\Varid{and}\;\mathcal{\hat{D}}} aside from functor laws.
As such, all other instances of categories created from a functor won't require further proving like this one did.

\end{alertblock}
\end{frame}

\begin{frame}{Monoidal categories and functors}

Generalized parallel composition shall be defined using a monoidal category:


\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{class}\;\Conid{Category}\;\Varid{k}\Rightarrow\Conid{Monoidal}\;\Varid{k}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}( \times )\mathbin{::}(\Varid{a}\;\text{\tt 'k'}\;\Varid{c})\rightarrow (\Varid{b}\;\text{\tt 'k'}\;\Varid{d})\rightarrow ((\Varid{a} \times \Varid{b})\;\text{\tt 'k'}\;(\Varid{c} \times \Varid{d})){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{instance}\;\Conid{Monoidal}\;(\rightarrow )\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{f} \times \Varid{g}\mathrel{=}\lambda (\Varid{a},\Varid{b})\rightarrow (\Varid{f}\;\Varid{a},\Varid{g}\;\Varid{b}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks



\begin{block}{Monoidal Functor definition}

A monoidal functor F between categories \ensuremath{\mathcal{U}\;\Varid{and}\;\mathcal{V}} is such that:
\begin{itemize}
    \item F is a functor
    \item F (f $\times$ g) = F f $\times$ F g
\end{itemize}
\end{block}
\end{frame}


\begin{frame}{Instance deduction}

From corollary 2.1 we can deduce that:

\ensuremath{\mathcal{D}^{+}\;(\Varid{f} \times \Varid{g})\mathrel{=}\lambda (\Varid{a},\Varid{b})\rightarrow \mathbf{let}\;\{\mskip1.5mu (\Varid{c},\Varid{f'})\mathrel{=}\mathcal{D}^{+}\;\Varid{f}\;\Varid{a};(\Varid{d},\Varid{g'})\mathrel{=}\mathcal{D}^{+}\;\Varid{g}\;\Varid{b}\mskip1.5mu\}} 

\ensuremath{\mathbf{in}\;((\Varid{c},\Varid{d}),\Varid{f'} \times \Varid{g'})}

\vspace{3mm}
\pause
Deriving F from \ensuremath{\mathcal{\hat{D}}} leaves us with the following definition:

\ensuremath{\mathcal{D}\;(\mathcal{D}^{+}\;\Varid{f}) \times \mathcal{D}\;(\mathcal{D}^{+}\;\Varid{g})\mathrel{=}\mathcal{D}\;(\mathcal{D}^{+}\;(\Varid{f} \times \Varid{g}))}

\vspace{3mm}
\pause
Using the same method as before, we replace \ensuremath{\mathcal{D}^{+}} with it's definition and generalize the condition:

\ensuremath{\mathcal{D}\;\Varid{f} \times \mathcal{D}\;\Varid{g}\mathrel{=}}

\ensuremath{\mathcal{D}\;(\lambda (\Varid{a},\Varid{b})\rightarrow \mathbf{let}\;\{\mskip1.5mu (\Varid{c},\Varid{f'})\mathrel{=}\Varid{f}\;\Varid{a};(\Varid{d},\Varid{g'})\mathrel{=}\Varid{g}\;\Varid{b}\mskip1.5mu\}\;\mathbf{in}\;((\Varid{c},\Varid{d}),\Varid{f'} \times \Varid{g'}))}

and this is enough for our new instance.
\end{frame}



\begin{frame}{Instance deduction}
\begin{block}{Categorical instance we've deduced}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{38}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{instance}\;\Conid{Monoidal}\;\mathcal{D}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\mathcal{D}\;\Varid{f} \times \mathcal{D}\;\Varid{g}\mathrel{=}\mathcal{D}\;(\lambda (\Varid{a},\Varid{b})\rightarrow \mathbf{let}\;\{\mskip1.5mu (\Varid{c},\Varid{f'})\mathrel{=}\Varid{f}\;\Varid{a};(\Varid{d},\Varid{g'})\mathrel{=}\Varid{g}\;\Varid{b}\mskip1.5mu\}{}\<[E]%
\\
\>[5]{}\hsindent{33}{}\<[38]%
\>[38]{}\mathbf{in}\;((\Varid{c},\Varid{d}),\Varid{f'} \times \Varid{g'})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{block}
\end{frame}




\begin{frame}{Cartesian categories and functors}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{class}\;\Conid{Monoidal}\;\Varid{k}\Rightarrow\Conid{Cartesian}\;\Varid{k}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{exl}\mathbin{::}(\Varid{a},\Varid{b})\;\text{\tt 'k'}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{exr}\mathbin{::}(\Varid{a},\Varid{b})\;\text{\tt 'k'}\;\Varid{b}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{dup}\mathbin{::}\Varid{a}\;\text{\tt 'k'}\;(\Varid{a},\Varid{a}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{instance}\;\Conid{Cartesian}\;(\rightarrow )\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{exl}\mathrel{=}\lambda (\Varid{a},\Varid{b})\rightarrow \Varid{a}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{exr}\mathrel{=}\lambda (\Varid{a},\Varid{b})\rightarrow \Varid{b}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{dup}\mathrel{=}\lambda \Varid{a}\rightarrow (\Varid{a},\Varid{a}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\vspace{-3mm}
\begin{block}

A cartesian functor F between categories \ensuremath{\mathcal{U}\;\Varid{and}\;\mathcal{V}} is such that:

\begin{itemize}
    \item F is a monoidal functor
    \item F exl = exl
    \item F exp = exp
    \item F dup = dup
\end{itemize}
\end{block}
\end{frame}




\begin{frame}{Instance deduction}

From corollary 3.1 and from exl, exr and dup being linear functions we can deduce that:

\ensuremath{\mathcal{D}^{+}\;\Varid{exl}\mathrel{=}\lambda \Varid{p}\rightarrow (\Varid{exl}\;\Varid{p},\Varid{exl})}

\ensuremath{\mathcal{D}^{+}\;\Varid{exr}\mathrel{=}\lambda \Varid{p}\rightarrow (\Varid{exr}\;\Varid{p},\Varid{exr})}

\ensuremath{\mathcal{D}^{+}\;\Varid{dup}\mathrel{=}\lambda \Varid{p}\rightarrow (\Varid{dup}\;\Varid{a},\Varid{dup})}

\vspace{3mm}
With this in mind we can arrive at our instance:

\ensuremath{\Varid{exl}\mathrel{=}\mathcal{D}\;(\mathcal{D}^{+}\;\Varid{exl})}

\ensuremath{\Varid{exr}\mathrel{=}\mathcal{D}\;(\mathcal{D}^{+}\;\Varid{exr})}

\ensuremath{\Varid{dup}\mathrel{=}\mathcal{D}\;(\mathcal{D}^{+}\;\Varid{dup})}

\end{frame}



\begin{frame}{Instance deduction} 

Replacing \ensuremath{\mathcal{D}^{+}} with it's definition and remembering linearD's definition we can obtain:

exl = linearD exl

exr = linearD exr

dup = linearD dup

\vspace{2mm}
and  convert this directly into a new instance:

\begin{block}{Categorical instance we've deduced}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{instance}\;\Conid{Cartesian}\;\Conid{D}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{exl}\mathrel{=}\Varid{linearD}\;\Varid{exl}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{exr}\mathrel{=}\Varid{linearD}\;\Varid{exr}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{dup}\mathrel{=}\Varid{linearD}\;\Varid{dup}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{block}
\end{frame}



\begin{frame}{Cocartesian category}

This type of categories is the dual of the cartesian type of categories.

\begin{block}{Note}
In this paper coproducts are categorical products, i.e., biproducts
\end{block}

\begin{block}{Definition}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{class}\;\Conid{Category}\;\Varid{k}\Rightarrow\Conid{Cocartesian}\;\Varid{k}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{inl}\mathbin{::}\Varid{a}\;\text{\tt 'k'}\;(\Varid{a},\Varid{b}){}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{inr}\mathbin{::}\Varid{b}\;\text{\tt 'k'}\;(\Varid{a},\Varid{b}){}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{jam}\mathbin{::}(\Varid{a},\Varid{a})\;\text{\tt 'k'}\;\Varid{a}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{block}
\end{frame}



\begin{frame}{Cocartesian functors}

\begin{block}{Cocartesian functor definition}

A cocartesian functor F between categories \ensuremath{\mathcal{U}\;\Varid{and}\;\mathcal{V}} is such that:
\begin{itemize}
    \item F is a functor
    \item F inl = inl
    \item F inr = inr
    \item F jam = jam
\end{itemize}
\end{block}
\end{frame}

%Ar1
\section{Fork and Join}
\begin{slide}{Fork and Join}
    \begin{itemize}
        \item
            \ensuremath{ \Delta \mathbin{::}\Conid{Cartesian}\;\Varid{k}\Rightarrow(\Varid{a}\;\text{\tt 'k'}\;\Varid{c})\rightarrow (\Varid{a}\;\text{\tt 'k'}\;\Varid{d})\rightarrow (\Varid{a}\;\text{\tt 'k'}\;(\Varid{c} \times \Varid{d}))}
        \item
            \ensuremath{ \nabla \mathbin{::}\Conid{Cartesian}\;\Varid{k}\Rightarrow(\Varid{c}\;\text{\tt 'k'}\;\Varid{a})\rightarrow (\Varid{d}\;\text{\tt 'k'}\;\Varid{a})\rightarrow ((\Varid{c} \times \Varid{d})\;\text{\tt 'k'}\;\Varid{a})}
    \end{itemize}
\end{slide}

\begin{slide}{Instance of \ensuremath{\rightarrow^+ }}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{newtype}\;\Varid{a}\rightarrow^+ \Varid{b}\mathrel{=}\Conid{AddFun}\;(\Varid{a}\rightarrow \Varid{b}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{instance}\;\Conid{Category}\;(\rightarrow^+ )\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\mathbf{type}\;\Conid{Obj}\;(\rightarrow^+ )\mathrel{=}\Conid{Additive}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{id}\mathrel{=}\Conid{AddFun}\;\Varid{id}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Conid{AddFun}\;\Varid{g}\mathbin{\circ}\Conid{AddFun}\;\Varid{f}\mathrel{=}\Conid{AddFun}\;(\Varid{g}\mathbin{\circ}\Varid{f}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{instance}\;\Conid{Monoidal}\;(\rightarrow^+ )\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Conid{AddFun}\;\Varid{f} \times \Conid{AddFun}\;\Varid{g}\mathrel{=}\Conid{AddFun}\;(\Varid{f} \times \Varid{g}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{instance}\;\Conid{Cartesian}\;(\rightarrow^+ )\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{exl}\mathrel{=}\Conid{AddFun}\;\Varid{exl}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{exr}\mathrel{=}\Conid{AddFun}\;\Varid{exr}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{dup}\mathrel{=}\Conid{AddFun}\;\Varid{dup}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{slide}

\begin{slide}{Instance of \ensuremath{\rightarrow^+ }}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{instance}\;\Conid{Cocartesian}\;(\rightarrow^+ )\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{inl}\mathrel{=}\Conid{AddFun}\;\Varid{inlF}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{inr}\mathrel{=}\Conid{AddFun}\;\Varid{inrF}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{jam}\mathrel{=}\Conid{AddFun}\;\Varid{jamF}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{inlF}\mathbin{::}\Conid{Additive}\;\Varid{b}\Rightarrow\Varid{a}\rightarrow \Varid{a} \times \Varid{b}{}\<[E]%
\\
\>[B]{}\Varid{inrF}\mathbin{::}\Conid{Additive}\;\Varid{a}\Rightarrow\Varid{b}\rightarrow \Varid{a} \times \Varid{b}{}\<[E]%
\\
\>[B]{}\Varid{jamF}\mathbin{::}\Conid{Additive}\;\Varid{a}\Rightarrow\Varid{a} \times \Varid{a}\rightarrow \Varid{a}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{inlF}\mathrel{=}\lambda \Varid{a}\rightarrow (\Varid{a},\mathrm{0}){}\<[E]%
\\
\>[B]{}\Varid{inrF}\mathrel{=}\lambda \Varid{b}\rightarrow (\mathrm{0},\Varid{b}){}\<[E]%
\\
\>[B]{}\Varid{jamF}\mathrel{=}\lambda (\Varid{a},\Varid{b})\rightarrow \Varid{a}\mathbin{+}\Varid{b}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{slide}

\section{Numeric operations}
\begin{slide}{NumCat definition}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[5]{}\mathbf{class}\;\Conid{NumCat}\;\Varid{k}\;\Varid{a}\;\mathbf{where}{}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\Varid{negateC}\mathbin{::}\Varid{a}\mathbin{‘}\Varid{k}\mathbin{‘}\Varid{a}{}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\Varid{addC}\mathbin{::}(\Varid{a} \times \Varid{a})\mathbin{‘}\Varid{k}\mathbin{‘}\Varid{a}{}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\Varid{mulC}\mathbin{::}(\Varid{a} \times \Varid{a})\mathbin{‘}\Varid{k}\mathbin{‘}\Varid{a}{}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\mathbin{...}{}\<[E]%
\\[\blanklineskip]%
\>[5]{}\mathbf{instance}\;\Conid{Num}\;\Varid{a}\Rightarrow\Conid{NumCat}\;(\rightarrow )\;\Varid{a}\;\mathbf{where}{}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\Varid{negateC}\mathrel{=}\Varid{negate}{}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\Varid{addC}\mathrel{=}\Varid{uncurry}\;(\mathbin{+}){}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\Varid{mulC}\mathrel{=}\Varid{uncurry}\;(\mathbin{*}){}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\mathbin{...}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{slide}

\begin{frame}
    \ensuremath{\mathcal{D}\;(\Varid{negate}\;\Varid{u})\mathrel{=}\Varid{negate}\;(\mathcal{D}\;\Varid{u})}\\
    \ensuremath{\mathcal{D}\;(\Varid{u}\mathbin{+}\Varid{v})\mathrel{=}\mathcal{D}\;\Varid{u}\mathbin{+}\mathcal{D}\;\Varid{v}}\\
    \ensuremath{\mathcal{D}\;(\Varid{u}\mathbin{*}\Varid{v})\mathrel{=}\Varid{u}\mathbin{*}\mathcal{D}\;\Varid{v}\mathbin{+}\Varid{v}\mathbin{*}\mathcal{D}\;\Varid{u}}\\
    \begin{itemize}
        \item
            Imprecise on the nature of u and v.
        \item
            A precise and simpler definition would be to differentiate the operations themselves.
    \end{itemize}
\end{frame}

\begin{frame}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[5]{}\mathbf{class}\;\Conid{Scalable}\;\Varid{k}\;\Varid{a}\;\mathbf{where}{}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\Varid{scale}\mathbin{::}\Varid{a}\rightarrow (\Varid{a}\mathbin{‘}\Varid{k}\mathbin{‘}\Varid{a}){}\<[E]%
\\[\blanklineskip]%
\>[5]{}\mathbf{instance}\;\Conid{Num}\;\Varid{a}\Rightarrow\Conid{Scalable}\;(\rightarrow^+ )\;\Varid{a}\;\mathbf{where}{}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\Varid{scale}\;\Varid{a}\mathrel{=}\Conid{AddFun}\;(\lambda \Varid{da}\rightarrow \Varid{a}\mathbin{*}\Varid{da}){}\<[E]%
\\[\blanklineskip]%
\>[5]{}\mathbf{instance}\;\Conid{NumCat}\;\Conid{D}\;\mathbf{where}{}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\Varid{negateC}\mathrel{=}\Varid{linearD}\;\Varid{negateC}{}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\Varid{addC}\mathrel{=}\Varid{linearD}\;\Varid{addC}{}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\Varid{mulC}\mathrel{=}\Conid{D}\;(\lambda (\Varid{a},\Varid{b})\rightarrow (\Varid{a}\mathbin{*}\Varid{b},\Varid{scale}\;\Varid{b}\; \nabla \;\Varid{scale}\;\Varid{a})){}\<[E]%
\\[\blanklineskip]%
\>[5]{}\mathbf{instance}\;\Conid{FloatingCat}\;\Conid{D}\;\mathbf{where}{}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\Varid{sinC}\mathrel{=}\Conid{D}\;(\lambda \Varid{a}\rightarrow (\Varid{sin}\;\Varid{a},\Varid{scale}\;(\Varid{cos}\;\Varid{a}))){}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\Varid{cosC}\mathrel{=}\Conid{D}\;(\lambda \Varid{a}\rightarrow (\Varid{cos}\;\Varid{a},\Varid{scale}\;(\mathbin{-}\Varid{sin}\;\Varid{a}))){}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\Varid{expC}\mathrel{=}\Conid{D}\;(\lambda \Varid{a}\rightarrow \mathbf{let}\;\Varid{e}\mathrel{=}\Varid{exp}\;\Varid{a}\;\mathbf{in}\;(\Varid{e},\Varid{scale}\;\Varid{e})){}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\mathbin{...}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{frame}

\begin{frame}{Examples}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[5]{}\Varid{sqr}\mathbin{::}\Conid{Num}\;\Varid{a}\Rightarrow\Varid{a}\rightarrow \Varid{a}{}\<[E]%
\\
\>[5]{}\Varid{sqr}\;\Varid{a}\mathrel{=}\Varid{a}\mathbin{*}\Varid{a}{}\<[E]%
\\[\blanklineskip]%
\>[5]{}\Varid{magSqr}\mathbin{::}\Conid{Num}\;\Varid{a}\Rightarrow\Varid{a} \times \Varid{a}\rightarrow \Varid{a}{}\<[E]%
\\
\>[5]{}\Varid{magSqr}\;(\Varid{a},\Varid{b})\mathrel{=}\Varid{sqr}\;\Varid{a}\mathbin{+}\Varid{sqr}\;\Varid{b}{}\<[E]%
\\[\blanklineskip]%
\>[5]{}\Varid{cosSinProd}\mathbin{::}\Conid{Floating}\;\Varid{a}\Rightarrow\Varid{a} \times \Varid{a}\rightarrow \Varid{a} \times \Varid{a}{}\<[E]%
\\
\>[5]{}\Varid{cosSinProd}\;(\Varid{x},\Varid{y})\mathrel{=}(\Varid{cos}\;\Varid{z},\Varid{sin}\;\Varid{z})\;\mathbf{where}\;\Varid{z}\mathrel{=}\Varid{x}\mathbin{*}\Varid{y}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\begin{block}{With a compiler plugin we can obtain}
\ensuremath{\Varid{sqr}\mathrel{=}\Varid{mulC}\mathbin{\circ}(\Varid{id}\; \Delta \;\Varid{id})}\\
\ensuremath{\Varid{magSqr}\mathrel{=}\Varid{addC}\mathbin{\circ}(\Varid{mulC}\mathbin{\circ}(\Varid{exl}\; \Delta \;\Varid{exl})\; \Delta \;\Varid{mulC}\mathbin{\circ}(\Varid{exr}\; \Delta \;\Varid{exr}))}\\
\ensuremath{\Varid{cosSinProd}\mathrel{=}(\Varid{cosC}\; \Delta \;\Varid{sinC})\mathbin{\circ}\Varid{mulC}}\\
\end{block} 
\end{frame}

\section{Generalizing Automatic Differentiation}
\begin{frame}{Generalizing Automatic Differentiation}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[5]{}\mathbf{newtype}\; D_k \;\Varid{a}\;\Varid{b}\mathrel{=}\Conid{D}\;(\Varid{a}\rightarrow \Varid{b} \times (\Varid{a}\mathbin{‘}\Varid{k}\mathbin{‘}\Varid{b})){}\<[E]%
\\[\blanklineskip]%
\>[5]{}\Varid{linearD}\mathbin{::}(\Varid{a}\rightarrow \Varid{b})\rightarrow (\Varid{a}\mathbin{‘}\Varid{k}\mathbin{‘}\Varid{b})\rightarrow  D_k \;\Varid{a}\;\Varid{b}{}\<[E]%
\\
\>[5]{}\Varid{linearD}\;\Varid{f}\;\Varid{f'}\mathrel{=}\Conid{D}\;(\lambda \Varid{a}\rightarrow (\Varid{f}\;\Varid{a},\Varid{f'})){}\<[E]%
\\[\blanklineskip]%
\>[5]{}\mathbf{instance}\;\Conid{Category}\;\Varid{k}\Rightarrow\Conid{Category}\; D_k \;\mathbf{where}{}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\mathbf{type}\;\Conid{Obj}\; D_k \mathrel{=}\Conid{Additive}\mathbin{∧}\Conid{Obj}\;\Varid{k}\mathbin{...}{}\<[E]%
\\[\blanklineskip]%
\>[5]{}\mathbf{instance}\;\Conid{Monoidal}\;\Varid{k}\Rightarrow\Conid{Monoidal}\; D_k \;\mathbf{where}\mathbin{...}{}\<[E]%
\\[\blanklineskip]%
\>[5]{}\mathbf{instance}\;\Conid{Cartesian}\;\Varid{k}\Rightarrow\Conid{Cartesian}\; D_k \;\mathbf{where}\mathbin{...}{}\<[E]%
\\[\blanklineskip]%
\>[5]{}\mathbf{instance}\;\Conid{Cocartesian}\;\Varid{k}\Rightarrow\Conid{Cocartesian}\; D_k \;\mathbf{where}{}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\Varid{inl}\mathrel{=}\Varid{linearD}\;\Varid{inlF}\;\Varid{inl}{}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\Varid{inr}\mathrel{=}\Varid{linearD}\;\Varid{inrF}\;\Varid{inr}{}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\Varid{jam}\mathrel{=}\Varid{linearD}\;\Varid{jamF}\;\Varid{jam}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\end{frame}
\begin{frame}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[5]{}\mathbf{instance}\;\Conid{Scalable}\;\Varid{k}\;\Varid{s}\mathbin{⇒}\Conid{NumCat}\; D_k \;\Varid{s}\;\mathbf{where}{}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\Varid{negateC}\mathrel{=}\Varid{linearD}\;\Varid{negateC}\;\Varid{negateC}{}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\Varid{addC}\mathrel{=}\Varid{linearD}\;\Varid{addC}\;\Varid{addC}{}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\Varid{mulC}\mathrel{=}\Conid{D}\;(\lambda (\Varid{a},\Varid{b})\rightarrow (\Varid{a}\mathbin{*}\Varid{b},\Varid{scale}\;\Varid{b}\; \nabla \;\Varid{scale}\;\Varid{a})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{frame}

%Ne2

\begin{frame}{Matrices}
There exists three, non-exclusive, possibilities for a nonempty matrix $W$:
\vspace{1mm}
\begin{itemize}
	\item width $W$ = height $W$ = $1$;
	\vspace{1.5mm}
	\item W is the horizontal juxtaposition of two matrices $U$ and $V$,\\
	 where height $W$ = height $U$ = height $V$ and\\
	 width $W$ = width $U$ $+$ width $V$;
	 \vspace{1.5mm}
	\item W is the vertical juxtaposition of two matrices $U$ and $V$,\\
	 where width $W$ = width $U$ = width $V$ and\\ 
	 height $W$ = height $U$ $+$ height $V$.
\end{itemize}

\end{frame}

\begin{frame}{Extracting a Data Representation}

%In addition to what we have used so far, we also need a Data Representation. 
In machine learning, a Gradient-based optimization works by searching for local
minima in the domain of a differentiable function $f :: a \to s$. Each step in the search is in the direction opposite of the gradient of $f$, which is a vector form of $\mathcal{D}\ f$.

\pause
\vspace{5mm}
Given a linear map  $f' :: U \multimap V$ represented as a function, it is possible to extract a Jacobian
matrix by applying $f$ to every vector in a basis of $U$.

\end{frame}

\begin{frame}{Generalized Matrices}
Given a scalar field $s$, a free vector space has the form $p \to s$ for some $p$, where the
cardinality of $p$ is the dimension of the vector space and there exists a finite number of values for $p$.

\pause

\vspace{5mm}

In particular, we can represent vector spaces over a given field as a representable functor, i.e., a functor F such that: $$\exists p\ \forall s\ F\ s\ \cong\ p \to s$$
\end{frame}

%Ez2
\section{Reverse-Mode Automatic Differentiation(RAD)}


\begin{frame}{A short introdution}

\begin{itemize}
    \item We've derived and generalized an AD algorithm using categories
    \item With fully right-associated compositions this algorithm becomes a foward-mode AD and with fully left-associated becomes a reverse-mode AD
    \item We want to obtain generalized FAD and RAD algorithms 
    \item How do we describe this in Categorical notation?
\end{itemize}

\end{frame}




\begin{frame}{Converting morfisms}

Given a category k we can represent its morfisms the following way:

\begin{block}{Left-Compose functions}
\ensuremath{\Varid{f}\mathbin{::}\Varid{a}\;\text{\tt 'k'}\;\Varid{b}\Rightarrow(\mathbin{\circ}\Varid{f})\mathbin{::}(\Varid{b}\;\text{\tt 'k'}\;\Varid{r})\rightarrow (\Varid{a}\;\text{\tt 'k'}\;\Varid{r})} where r is any object of k.
\end{block}

If h is the morfism we'll compose with f then h is the continuation of f.
\end{frame}




\begin{frame}{Instance deduction}

\begin{block}{Defining new type}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{newtype}\;Cont^{k}_{r}\;\Varid{a}\;\Varid{b}\mathrel{=}\Conid{Cont}\;((\Varid{b}\;\text{\tt 'k'}\;\Varid{r})\rightarrow (\Varid{a}\;\text{\tt 'k'}\;\Varid{r})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{block}

\begin{block}{Functor derived from type}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{cont}\mathbin{::}\Conid{Category}\;\Varid{k}\Rightarrow(\Varid{a}\;\text{\tt 'k'}\;\Varid{b})\rightarrow Cont^{k}_{r}\;\Varid{a}\;\Varid{b}{}\<[E]%
\\
\>[B]{}\Varid{cont}\;\Varid{f}\mathrel{=}\Conid{Cont}\;(\mathbin{\circ}\Varid{f}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{block}

\end{frame}



\begin{frame}{Instance deduction}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{instance}\;\Conid{Category}\;\Varid{k}\Rightarrow\Conid{Category}\;Cont^{k}_{r}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{id}\mathrel{=}\Conid{Cont}\;\Varid{id}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{Cont}\;\Varid{g}\mathbin{\circ}\Conid{Cont}\;\Varid{f}\mathrel{=}\Conid{Cont}\;(\Varid{f}\mathbin{\circ}\Varid{g}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{instance}\;\Conid{Monoidal}\;\Varid{k}\Rightarrow\Conid{Monoidal}\;Cont^{k}_{r}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{Conf}\;\Varid{f} \times \Conid{Cont}\;\Varid{g}\mathrel{=}\Conid{Cont}\;(\Varid{join}\mathbin{\circ}(\Varid{f} \times \Varid{g})\mathbin{\circ}\Varid{unjoin}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{instance}\;\Conid{Cartesian}\;\Varid{k}\Rightarrow\Conid{Cartesian}\;Cont^{k}_{r}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{exl}\mathrel{=}\Conid{Cont}\;(\Varid{join}\mathbin{\circ}\Varid{inl});\Varid{exr}\mathrel{=}\Conid{Cont}\;(\Varid{join}\mathbin{\circ}\Varid{inr}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{dup}\mathrel{=}\Conid{Cont}\;(\Varid{jam}\mathbin{\circ}\Varid{unjoin}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{instance}\;\Conid{Cocartesian}\;\Varid{k}\Rightarrow\Conid{Cocartesian}\;Cont^{k}_{r}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{inl}\mathrel{=}\Conid{Cont}\;(\Varid{exl}\mathbin{\circ}\Varid{unjoin});\Varid{inr}\mathrel{=}\Conid{Cont}\;(\Varid{exr}\mathbin{\circ}\Varid{unjoin}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{jam}\mathrel{=}\Conid{Cont}\;(\Varid{join}\mathbin{\circ}\Varid{dup}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{instance}\;\Conid{Scalable}\;\Varid{k}\;\Varid{a}\Rightarrow\Conid{Scalable}\;Cont^{k}_{r}\;\Varid{a}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{scale}\;\Varid{s}\mathrel{=}\Conid{Cont}\;(\Varid{scale}\;\Varid{s}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{frame}







\section{Gradient and Duality}

\begin{frame}{A short introdution}

Due to it's widespread use in ML we'll talk about a specific case of RAD: computing gradients(derivatives of functions with scalar codomains)

A vector space A over a scalar field s has A $\multimap$ s as its dual.

Each linear map in A $\multimap$ s can be represented in the form of dot u for some u :: A where

\begin{block}{Definition and instanciation}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{class}\;\Conid{HasDot}\;(\Conid{S})\;\Varid{u}\;\mathbf{where}\;\Varid{dot}\mathbin{::}\Varid{u}\rightarrow (\Varid{u}\;\multimap \;\Varid{s}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{instance}\;\Conid{HasDot}\;(\Conid{IR})\;\Conid{IR}\;\mathbf{where}\;\Varid{dot}\mathrel{=}\Varid{scale}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{instance}\;(\Conid{HasDot}\;(\Conid{S})\;\Varid{a},\Conid{HasDot}\;(\Conid{S})\;\Varid{b}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Rightarrow\Conid{HasDot}\;(\Conid{S})\;(\Varid{a} \times \Varid{b}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathbf{where}\;\Varid{dot}\;(\Varid{u},\Varid{v})\mathrel{=}\Varid{dot}\;\Varid{u}\; \Delta \;\Varid{dot}\;\Varid{v}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{block}

\end{frame}



\begin{frame}{Instance deduction}

The internal representation of $Cont_{\multimap}^{s}$ a b is (b $\multimap$ s) \ensuremath{\rightarrow } (a $\multimap$ s) which is isomorfic to (a \ensuremath{\rightarrow } b).

\begin{block}{Type definition for duality}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{newtype}\; Dual_k \;\Varid{a}\;\Varid{b}\mathrel{=}\Conid{Dual}\;(\Varid{b}\;\text{\tt 'k'}\;\Varid{a}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{block}

\end{frame}




\begin{frame}{Instance deduction}

All we need to do to create dual representations of linear maps is to
convert from $Cont_{k}^{S}$ to $Dual_{k}$ using a functor:

\begin{block}{Functor definition}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{asDual}\mathbin{::}(\Conid{HasDot}\;(\Conid{S})\;\Varid{a},\Conid{HasDot}\;(\Conid{S})\;\Varid{b})\Rightarrow{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}((\Varid{b}\;\multimap \;\Varid{s})\rightarrow (\Varid{a}\;\multimap \;\Varid{s}))\rightarrow (\Varid{b}\;\multimap \;\Varid{a}){}\<[E]%
\\
\>[B]{}\Varid{asDual}\;(\Conid{Cont}\;\Varid{f})\mathrel{=}\Conid{Dual}\;(\Varid{onDot}\;\Varid{f}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

where

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{onDot}\mathbin{::}(\Conid{HasDot}\;(\Conid{S})\;\Varid{a},\Conid{HasDot}\;(\Conid{S})\;\Varid{b})\Rightarrow{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}((\Varid{b}\;\multimap \;\Varid{s})\rightarrow (\Varid{a}\;\multimap \;\Varid{s}))\rightarrow (\Varid{b}\;\multimap \;\Varid{a}){}\<[E]%
\\
\>[B]{}\Varid{onDot}\;\Varid{f}\mathrel{=}\Varid{dot}^{-1}\mathbin{\circ}\Varid{f}\mathbin{\circ}\Varid{dot}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{block}

\end{frame}



\begin{frame}{Instance deduction}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{21}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{instance}\;\Conid{Category}\;\Varid{k}\Rightarrow\Conid{Category}\; Dual_k \;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{id}\mathrel{=}\Conid{Dual}\;\Varid{id}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{Dual}\;\Varid{g}\mathbin{\circ}\Conid{Dual}\;\Varid{f}\mathrel{=}\Conid{Dual}\;(\Varid{f}\mathbin{\circ}\Varid{g}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{instance}\;\Conid{Monoidal}\;\Varid{k}\Rightarrow\Conid{Monoidal}\; Dual_k \;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{Dual}\;\Varid{f} \times \Conid{Dual}\;\Varid{g}\mathrel{=}\Conid{Dual}\;(\Varid{f} \times \Varid{g}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{instance}\;\Conid{Cartesian}\;\Varid{k}\Rightarrow\Conid{Cartesian}\; Dual_k \;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{exl}\mathrel{=}\Conid{Dual}\;\Varid{inl};{}\<[21]%
\>[21]{}\Varid{exr}\mathrel{=}\Conid{Dual}\;\Varid{inr}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{dup}\mathrel{=}\Conid{Dual}\;\Varid{jam}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{instance}\;\Conid{Cocartesian}\;\Varid{k}\Rightarrow\Conid{Cocartesian}\; Dual_k \;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{inl}\mathrel{=}\Conid{Dual}\;\Varid{exl};\Varid{inr}\mathrel{=}\Conid{Dual}\;\Varid{exr}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{jam}\mathrel{=}\Conid{Dual}\;\Varid{dup}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{instance}\;\Conid{Scalable}\;\Varid{k}\Rightarrow\Conid{Scalable}\; Dual_k \;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{scale}\;\Varid{s}\mathrel{=}\Conid{Dual}\;(\Varid{scale}\;\Varid{s}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{frame}



\begin{frame}{Final notes}

\begin{itemize}
  \item \ensuremath{( \nabla )\;\Varid{and}\;( \Delta )} mutually dualize 
  
  \ensuremath{(\Conid{Dual}\;\Varid{f}\; \nabla \;\Conid{Dual}\;\Varid{g})\mathrel{=}\Conid{Dual}\;(\Varid{f}\; \Delta \;\Varid{g})\;\Varid{and}\;\Conid{Dual}\;\Varid{f}\; \Delta \;\Conid{Dual}\;\Varid{g}\mathrel{=}\Conid{Dual}\;(\Varid{f}\; \nabla \;\Varid{g}))}
  \item Using the definition from chapter 8 we can determine that the duality of a matrix corresponds to it's transposition
\end{itemize}

\end{frame}


\section{Foward-Mode Automatic Differentiation(FAD)}

\begin{frame}{Fowards-mode Automatic Differentiation(FAD)}

We can use the same deductions we've done in Cont and Dual to derive a category with full right-side association, thus creating a generized FAD algorithm.

This algorithm is far more apropriated for low dimention domains.


\begin{block}{Type definition and functor from type}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{newtype}\;Begin^{k}_{r}\;\Varid{a}\;\Varid{b}\mathrel{=}\Conid{Begin}\;((\Varid{r}\;\text{\tt 'k'}\;\Varid{a})\rightarrow (\Varid{r}\;\text{\tt 'k'}\;\Varid{b})){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{begin}\mathbin{::}\Conid{Category}\;\Varid{k}\Rightarrow(\Varid{a}\;\text{\tt 'k'}\;\Varid{b})\rightarrow Begin^{k}_{r}\;\Varid{a}\;\Varid{b}{}\<[E]%
\\
\>[B]{}\Varid{begin}\;\Varid{f}\mathrel{=}\Conid{Begin}\;(\Varid{f}\mathbin{\circ}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{block}

We can derive categorical instances from the functor above and we can choose r to be the scalar field s, noting that s $\multimap$ a is isomorfic to a.


\end{frame}

%Ar2
\section{Scaling Up}
\begin{frame}{Scaling Up}
\begin{itemize}
\item
Practical applications often involve high-dimensional spaces.
\item
Binary products are a very inefficient and unwieldy way of encoding high-dimensional spaces.
\item
A practical alternative is to consider n-ary products as representable functors(?)
\end{itemize}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[5]{}\mathbf{class}\;\Conid{Category}\;\Varid{k}\Rightarrow\Conid{MonoidalI}\;\Varid{k}\;\Varid{h}\;\mathbf{where}{}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\Varid{crossI}\mathbin{::}\Varid{h}\;(\Varid{a}\mathbin{‘}\Varid{k}\mathbin{‘}\Varid{b})\rightarrow (\Varid{h}\;\Varid{a}\mathbin{‘}\Varid{k}\mathbin{‘}\Varid{h}\;\Varid{b}){}\<[E]%
\\[\blanklineskip]%
\>[5]{}\mathbf{instance}\;\Conid{Zip}\;\Varid{h}\Rightarrow\Conid{MonoidalI}\;(\rightarrow )\;\Varid{h}\;\mathbf{where}{}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\Varid{crossI}\mathrel{=}\Varid{zipWith}\;\Varid{id}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\end{frame}

\begin{frame}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{17}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[5]{}\mathbf{class}\;\Conid{MonoidalI}\;\Varid{k}\;\Varid{h}\Rightarrow\Conid{CartesianI}\;\Varid{k}\;\Varid{h}\;\mathbf{where}{}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\Varid{exI}{}\<[17]%
\>[17]{}\mathbin{::}\Varid{h}\;(\Varid{h}\;\Varid{a}\mathbin{‘}\Varid{k}\mathbin{‘}\Varid{a}){}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\Varid{replI}{}\<[17]%
\>[17]{}\mathbin{::}\Varid{a}\mathbin{‘}\Varid{k}\mathbin{‘}\Varid{h}\;\Varid{a}{}\<[E]%
\\[\blanklineskip]%
\>[5]{}\mathbf{class}\;(\Conid{Representable}\;\Varid{h},\Conid{Zip}\;\Varid{h},\Conid{Pointed}\;\Varid{h})\Rightarrow{}\<[E]%
\\
\>[5]{}\hsindent{8}{}\<[13]%
\>[13]{}\Conid{CartesianI}\;(\rightarrow )\;\Varid{h}\;\mathbf{where}{}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\Varid{exI}\mathrel{=}\Varid{tabulate}\;(\Varid{flip}\;\Varid{index}){}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\Varid{replI}\mathrel{=}\Varid{point}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\begin{itemize}
\item
    The following is not the class the author was thinking
\end{itemize}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{18}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[5]{}\mathbf{class}\;\Conid{Representable}\;\Varid{h}\;\mathbf{where}{}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\mathbf{type}\;\Conid{Rep}\;\Varid{h}\mathbin{::}\mathbin{*}{}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\Varid{tabulate}\mathbin{::}(\Conid{Rep}\;\Varid{h}\rightarrow \Varid{a})\rightarrow \Varid{h}\;\Varid{a}{}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\Varid{index}{}\<[18]%
\>[18]{}\mathbin{::}\Varid{h}\;\Varid{a}\rightarrow \Conid{Rep}\;\Varid{h}\rightarrow \Varid{a}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{frame}

\begin{frame}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{32}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[5]{}\mathbf{class}\;\Conid{MonoidalI}\;\Varid{k}\;\Varid{h}\Rightarrow\Conid{CocartesianI}\;\Varid{k}\;\Varid{h}\;\mathbf{where}{}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\Varid{inI}\mathbin{::}\Varid{h}\;(\Varid{a}\mathbin{‘}\Varid{k}\mathbin{‘}\Varid{h}\;\Varid{a}){}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\Varid{jamI}\mathbin{::}\Varid{h}\;\Varid{a}\mathbin{‘}\Varid{k}\mathbin{‘}\Varid{a}{}\<[E]%
\\[\blanklineskip]%
\>[5]{}\mathbf{instance}\;(\Conid{MonoidalI}\;\Varid{k}\;\Varid{h},\Conid{Zip}\;\Varid{h})\Rightarrow\Conid{MonoidalI}\; D_k \;\Varid{h}\;\mathbf{where}{}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\Varid{crossI}\;\Varid{fs}\mathrel{=}\Conid{D}\;((\Varid{id} \times \Varid{crossI})\mathbin{\circ}\Varid{unzip}\mathbin{\circ}\Varid{crossI}\;(\Varid{fmap}\;\Varid{unD}\;\Varid{fs})){}\<[E]%
\\[\blanklineskip]%
\>[5]{}\mathbf{instance}\;(\Conid{CocartesianI}\;(\rightarrow )\;\Varid{h},\Conid{CartesianI}\;\Varid{k}\;\Varid{h},\Conid{Zip}\;\Varid{h})\Rightarrow{}\<[E]%
\\
\>[5]{}\hsindent{8}{}\<[13]%
\>[13]{}\Conid{CartesianI}\; D_k \;\Varid{h}\;\mathbf{where}{}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\Varid{exI}\mathrel{=}\Varid{linearD}\;\Varid{exI}\;\Varid{exI}{}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\Varid{replI}\mathrel{=}\Varid{zipWith}\;\Varid{linearD}\;\Varid{replI}\;\Varid{replI}{}\<[E]%
\\[\blanklineskip]%
\>[5]{}\mathbf{instance}\;(\Conid{CocartesianI}\;\Varid{k}\;\Varid{h},\Conid{Zip}\;\Varid{h})\Rightarrow\Conid{CocartesianI}\; D_k \;\Varid{h}\;\mathbf{where}{}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\Varid{inI}\mathrel{=}\Varid{zipWith}\;\Varid{linearD}\;{}\<[32]%
\>[32]{}\Varid{inIF}\;\Varid{inl}{}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\Varid{jamI}\mathrel{=}\Varid{linearD}\;\Varid{sum}\;\Varid{jamI}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{frame}

\begin{frame}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{32}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[5]{}\mathbf{class}\;\Conid{MonoidalI}\;\Varid{k}\;\Varid{h}\Rightarrow\Conid{CocartesianI}\;\Varid{k}\;\Varid{h}\;\mathbf{where}{}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\Varid{inI}\mathbin{::}\Varid{h}\;(\Varid{a}\mathbin{‘}\Varid{k}\mathbin{‘}\Varid{h}\;\Varid{a}){}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\Varid{jamI}\mathbin{::}\Varid{h}\;\Varid{a}\mathbin{‘}\Varid{k}\mathbin{‘}\Varid{a}{}\<[E]%
\\[\blanklineskip]%
\>[5]{}\mathbf{instance}\;(\Conid{MonoidalI}\;\Varid{k}\;\Varid{h},\Conid{Zip}\;\Varid{h})\Rightarrow\Conid{MonoidalI}\; D_k \;\Varid{h}\;\mathbf{where}{}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\Varid{crossI}\;\Varid{fs}\mathrel{=}\Conid{D}\;((\Varid{id} \times \Varid{crossI})\mathbin{\circ}\Varid{unzip}\mathbin{\circ}\Varid{crossI}\;(\Varid{fmap}\;\Varid{unD}\;\Varid{fs})){}\<[E]%
\\[\blanklineskip]%
\>[5]{}\mathbf{instance}\;(\Conid{CocartesianI}\;(\rightarrow )\;\Varid{h},\Conid{CartesianI}\;\Varid{k}\;\Varid{h},\Conid{Zip}\;\Varid{h})\Rightarrow{}\<[E]%
\\
\>[5]{}\hsindent{8}{}\<[13]%
\>[13]{}\Conid{CartesianI}\; D_k \;\Varid{h}\;\mathbf{where}{}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\Varid{exI}\mathrel{=}\Varid{zipWith}\;\Varid{linearD}\;\Varid{exI}\;\Varid{exI}{}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\Varid{replI}\mathrel{=}\Varid{linearD}\;\Varid{replI}\;\Varid{replI}{}\<[E]%
\\[\blanklineskip]%
\>[5]{}\mathbf{instance}\;(\Conid{CocartesianI}\;\Varid{k}\;\Varid{h},\Conid{Zip}\;\Varid{h})\Rightarrow\Conid{CocartesianI}\; D_k \;\Varid{h}\;\mathbf{where}{}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\Varid{inI}\mathrel{=}\Varid{zipWith}\;\Varid{linearD}\;{}\<[32]%
\>[32]{}\Varid{inIF}\;\Varid{inl}{}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\Varid{jamI}\mathrel{=}\Varid{linearD}\;\Varid{sum}\;\Varid{jamI}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{frame}
\section{Related Work and conlusion}
\begin{frame}{Conclusion}
\begin{itemize}
\item
    Suggests that some of the work referred to does just a part of this paper.
\item
    This paper ([Elliott 2018]\cite{Elliott:2018}) is a follow up of [Elliott 2017]\cite{Elliott:2017} 
\item
    Suggests that this implementation is simple, efficient, it can free memory dinamically (RAD) and is naturally parallel.
\item
    Future work are detailed performace analysis; higher-order differentiation and automatic incrementation (continuing previous work [Elliott 2017]\cite{Elliott:2017})
\end{itemize}
\end{frame}

\section{Bibliography}
\bibliographystyle{acm}%{ACM-Reference-Format}
\bibliography{slides}
%fim

\end{document}


